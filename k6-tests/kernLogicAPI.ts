/**
 * Automatically generated by @grafana/openapi-to-k6: 0.3.2
 * Do not edit manually.
 * KernLogic API
 * Inventory and product management API
 * Service version: 1.0.0
 */
import { FormData } from "https://jslib.k6.io/formdata/0.0.2/index.js";

import { URL, URLSearchParams } from "https://jslib.k6.io/url/1.0.0/index.js";

import http from "k6/http";
import type { Params, Response, ResponseBody } from "k6/http";

/**
 * * `invite` - Invite Sent
 * `role_change` - Role Changed
 * `remove` - User Removed
 */
export type ActionEnum = (typeof ActionEnum)[keyof typeof ActionEnum];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ActionEnum = {
  invite: "invite",
  role_change: "role_change",
  remove: "remove",
} as const;

export interface AssetBundle {
  readonly id: number;
  /** @maxLength 255 */
  name: string;
  asset_ids: number[];
  readonly created_at: string;
}

export interface AssetBundleRequest {
  /**
   * @minLength 1
   * @maxLength 255
   */
  name: string;
  asset_ids: number[];
}

export interface Attribute {
  readonly id: number;
  readonly options: string;
  /**
   * Slug-like unique identifier per organization
   * @maxLength 64
   */
  code: string;
  /** @maxLength 255 */
  label: string;
  data_type: DataTypeEnum;
  is_localisable?: boolean;
  is_scopable?: boolean;
  readonly organization: number;
  /** @nullable */
  readonly created_by: number | null;
}

export interface AttributeGroup {
  readonly id: number;
  /** @maxLength 80 */
  name: string;
  /**
   * @minimum 0
   * @maximum 32767
   */
  order?: number;
  items?: AttributeGroupItem[];
}

export interface AttributeGroupItem {
  readonly id: number;
  attribute: number;
  /**
   * @minimum 0
   * @maximum 32767
   */
  order?: number;
}

export interface AttributeGroupItemRequest {
  attribute: number;
  /**
   * @minimum 0
   * @maximum 32767
   */
  order?: number;
}

export interface AttributeGroupRequest {
  /**
   * @minLength 1
   * @maxLength 80
   */
  name: string;
  /**
   * @minimum 0
   * @maximum 32767
   */
  order?: number;
  items?: AttributeGroupItemRequest[];
}

export interface AttributeRequest {
  /**
   * Slug-like unique identifier per organization
   * @minLength 1
   * @maxLength 64
   */
  code: string;
  /**
   * @minLength 1
   * @maxLength 255
   */
  label: string;
  data_type: DataTypeEnum;
  is_localisable?: boolean;
  is_scopable?: boolean;
}

export type AttributeValueValue = { [key: string]: unknown };

export interface AttributeValue {
  readonly id: number;
  /**
   * Legacy locale code field, use 'locale' instead
   * @maxLength 10
   * @nullable
   */
  locale_code?: string | null;
  /**
   * @maxLength 32
   * @nullable
   */
  channel?: string | null;
  value: AttributeValueValue;
  readonly organization: number;
  product: number;
  attribute: number;
  /**
   * The locale for this attribute value
   * @nullable
   */
  locale?: number | null;
  /** @nullable */
  readonly created_by: number | null;
}

export type AttributeValueDetailValue = { [key: string]: unknown };

/**
 * Serializer for attribute values with more detailed attribute information.
Used for list and retrieve actions.
 */
export interface AttributeValueDetail {
  readonly id: number;
  attribute: number;
  product: number;
  readonly organization: number;
  value: AttributeValueDetailValue;
  /**
   * The locale for this attribute value
   * @nullable
   */
  locale?: number | null;
  /**
   * @maxLength 32
   * @nullable
   */
  channel?: string | null;
  readonly attribute_code: string;
  readonly attribute_label: string;
  readonly attribute_type: string;
}

export type AttributeValueRequestValue = { [key: string]: unknown };

export interface AttributeValueRequest {
  /**
   * Legacy locale code field, use 'locale' instead
   * @maxLength 10
   * @nullable
   */
  locale_code?: string | null;
  /**
   * @maxLength 32
   * @nullable
   */
  channel?: string | null;
  value: AttributeValueRequestValue;
  product: number;
  attribute: number;
  /**
   * The locale for this attribute value
   * @nullable
   */
  locale?: number | null;
}

export type AuditLogDetails = { [key: string]: unknown };

export interface AuditLog {
  readonly id: number;
  action: ActionEnum;
  /** @nullable */
  user?: number | null;
  /** @nullable */
  organization?: number | null;
  /** @maxLength 50 */
  target_type: string;
  target_id: string;
  readonly timestamp: string;
  details?: AuditLogDetails;
}

/**
 * Serializer for hierarchical category model
 */
export interface Category {
  readonly id: number;
  /** @maxLength 100 */
  name: string;
  /** @nullable */
  parent?: number | null;
  readonly children: string;
}

/**
 * Serializer for hierarchical category model
 */
export interface CategoryRequest {
  /**
   * @minLength 1
   * @maxLength 100
   */
  name: string;
  /** @nullable */
  parent?: number | null;
}

export interface Currency {
  readonly iso_code: string;
  /** @maxLength 8 */
  symbol: string;
  /** @maxLength 50 */
  name: string;
  /**
   * @minimum 0
   * @maximum 32767
   */
  decimals?: number;
}

export interface CurrencyRequest {
  /**
   * @minLength 1
   * @maxLength 8
   */
  symbol: string;
  /**
   * @minLength 1
   * @maxLength 50
   */
  name: string;
  /**
   * @minimum 0
   * @maximum 32767
   */
  decimals?: number;
}

/**
 * * `text` - Text
 * `number` - Number
 * `boolean` - Boolean
 * `date` - Date
 * `select` - Select
 * `rich_text` - Rich Text
 * `price` - Price
 * `media` - Media
 * `measurement` - Measurement
 * `url` - URL
 * `email` - Email
 * `phone` - Phone
 */
export type DataTypeEnum = (typeof DataTypeEnum)[keyof typeof DataTypeEnum];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DataTypeEnum = {
  text: "text",
  number: "number",
  boolean: "boolean",
  date: "date",
  select: "select",
  rich_text: "rich_text",
  price: "price",
  media: "media",
  measurement: "measurement",
  url: "url",
  email: "email",
  phone: "phone",
} as const;

/**
 * * `skip` - Skip
 * `overwrite` - Overwrite
 * `abort` - Abort
 */
export type DuplicateStrategyEnum =
  (typeof DuplicateStrategyEnum)[keyof typeof DuplicateStrategyEnum];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DuplicateStrategyEnum = {
  skip: "skip",
  overwrite: "overwrite",
  abort: "abort",
} as const;

/**
 * Serializer for Product Family model
 */
export interface Family {
  readonly id: number;
  /** @maxLength 64 */
  code: string;
  /** @maxLength 255 */
  label: string;
  description?: string;
  attribute_groups?: FamilyAttributeGroup[];
  readonly created_at: string;
  readonly updated_at: string;
}

/**
 * Serializer for the FamilyAttributeGroup pivot model
 */
export interface FamilyAttributeGroup {
  readonly id: number;
  attribute_group: number;
  required?: boolean;
  /**
   * @minimum 0
   * @maximum 32767
   */
  order?: number;
}

/**
 * Serializer for the FamilyAttributeGroup pivot model
 */
export interface FamilyAttributeGroupRequest {
  attribute_group: number;
  required?: boolean;
  /**
   * @minimum 0
   * @maximum 32767
   */
  order?: number;
}

/**
 * Serializer for Product Family model
 */
export interface FamilyRequest {
  /**
   * @minLength 1
   * @maxLength 64
   */
  code: string;
  /**
   * @minLength 1
   * @maxLength 255
   */
  label: string;
  description?: string;
  attribute_groups?: FamilyAttributeGroupRequest[];
}

export type ImportTaskMapping = { [key: string]: unknown };

/**
 * Serializer for the ImportTask model.
Includes calculated fields for progress percentage and status display.
 */
export interface ImportTask {
  readonly id: number;
  csv_file: string;
  mapping: ImportTaskMapping;
  /** Strategy for handling duplicate SKUs

* `skip` - Skip
* `overwrite` - Overwrite
* `abort` - Abort */
  duplicate_strategy?: DuplicateStrategyEnum;
  readonly status: ImportTaskStatusEnum;
  readonly status_display: string;
  readonly processed: number;
  /** @nullable */
  readonly total_rows: number | null;
  readonly row_count: number;
  readonly progress_percentage: number;
  /** @nullable */
  readonly error_file: string | null;
  readonly error_file_url: string;
  /** Number of rows with errors */
  readonly error_count: number;
  /**
   * Execution time in seconds
   * @nullable
   */
  readonly execution_time: number | null;
  readonly created_at: string;
}

export type ImportTaskRequestMapping = { [key: string]: unknown };

/**
 * Serializer for the ImportTask model.
Includes calculated fields for progress percentage and status display.
 */
export interface ImportTaskRequest {
  csv_file: Blob;
  mapping: ImportTaskRequestMapping;
  /** Strategy for handling duplicate SKUs

* `skip` - Skip
* `overwrite` - Overwrite
* `abort` - Abort */
  duplicate_strategy?: DuplicateStrategyEnum;
}

/**
 * * `queued` - Queued
 * `running` - Running
 * `success` - Success
 * `partial_success` - Partial Success
 * `error` - Error
 */
export type ImportTaskStatusEnum =
  (typeof ImportTaskStatusEnum)[keyof typeof ImportTaskStatusEnum];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ImportTaskStatusEnum = {
  queued: "queued",
  running: "running",
  success: "success",
  partial_success: "partial_success",
  error: "error",
} as const;

/**
 * Serializer for the Locale model
 */
export interface Locale {
  readonly id: number;
  /** @maxLength 10 */
  code: string;
  /** @maxLength 50 */
  label: string;
  is_active?: boolean;
}

/**
 * Serializer for the Locale model
 */
export interface LocaleRequest {
  /**
   * @minLength 1
   * @maxLength 10
   */
  code: string;
  /**
   * @minLength 1
   * @maxLength 50
   */
  label: string;
  is_active?: boolean;
}

export interface Membership {
  readonly id: number;
  readonly user: string;
  readonly user_email: string;
  readonly user_name: string;
  readonly avatar_url: string;
  readonly role: Role;
  role_id: number;
  status?: MembershipStatusEnum;
  readonly invited_at: string;
  organization?: number;
  readonly last_login: string;
}

export interface MembershipRequest {
  role_id: number;
  status?: MembershipStatusEnum;
  organization?: number;
}

/**
 * * `pending` - Pending
 * `active` - Active
 */
export type MembershipStatusEnum =
  (typeof MembershipStatusEnum)[keyof typeof MembershipStatusEnum];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MembershipStatusEnum = {
  pending: "pending",
  active: "active",
} as const;

export interface PaginatedProductEventList {
  count?: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results?: ProductEvent[];
}

export interface PaginatedProductList {
  count?: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results?: Product[];
}

export interface PatchedAssetBundleRequest {
  /**
   * @minLength 1
   * @maxLength 255
   */
  name?: string;
  asset_ids?: number[];
}

export interface PatchedAttributeGroupRequest {
  /**
   * @minLength 1
   * @maxLength 80
   */
  name?: string;
  /**
   * @minimum 0
   * @maximum 32767
   */
  order?: number;
  items?: AttributeGroupItemRequest[];
}

export interface PatchedAttributeRequest {
  /**
   * Slug-like unique identifier per organization
   * @minLength 1
   * @maxLength 64
   */
  code?: string;
  /**
   * @minLength 1
   * @maxLength 255
   */
  label?: string;
  data_type?: DataTypeEnum;
  is_localisable?: boolean;
  is_scopable?: boolean;
}

export type PatchedAttributeValueRequestValue = { [key: string]: unknown };

export interface PatchedAttributeValueRequest {
  /**
   * Legacy locale code field, use 'locale' instead
   * @maxLength 10
   * @nullable
   */
  locale_code?: string | null;
  /**
   * @maxLength 32
   * @nullable
   */
  channel?: string | null;
  value?: PatchedAttributeValueRequestValue;
  product?: number;
  attribute?: number;
  /**
   * The locale for this attribute value
   * @nullable
   */
  locale?: number | null;
}

/**
 * Serializer for hierarchical category model
 */
export interface PatchedCategoryRequest {
  /**
   * @minLength 1
   * @maxLength 100
   */
  name?: string;
  /** @nullable */
  parent?: number | null;
}

export interface PatchedCurrencyRequest {
  /**
   * @minLength 1
   * @maxLength 8
   */
  symbol?: string;
  /**
   * @minLength 1
   * @maxLength 50
   */
  name?: string;
  /**
   * @minimum 0
   * @maximum 32767
   */
  decimals?: number;
}

/**
 * Serializer for Product Family model
 */
export interface PatchedFamilyRequest {
  /**
   * @minLength 1
   * @maxLength 64
   */
  code?: string;
  /**
   * @minLength 1
   * @maxLength 255
   */
  label?: string;
  description?: string;
  attribute_groups?: FamilyAttributeGroupRequest[];
}

export type PatchedImportTaskRequestMapping = { [key: string]: unknown };

/**
 * Serializer for the ImportTask model.
Includes calculated fields for progress percentage and status display.
 */
export interface PatchedImportTaskRequest {
  csv_file?: Blob;
  mapping?: PatchedImportTaskRequestMapping;
  /** Strategy for handling duplicate SKUs

* `skip` - Skip
* `overwrite` - Overwrite
* `abort` - Abort */
  duplicate_strategy?: DuplicateStrategyEnum;
}

/**
 * Serializer for the Locale model
 */
export interface PatchedLocaleRequest {
  /**
   * @minLength 1
   * @maxLength 10
   */
  code?: string;
  /**
   * @minLength 1
   * @maxLength 50
   */
  label?: string;
  is_active?: boolean;
}

export interface PatchedMembershipRequest {
  role_id?: number;
  status?: MembershipStatusEnum;
  organization?: number;
}

export interface PatchedPriceTypeRequest {
  /**
   * @minLength 1
   * @maxLength 32
   * @pattern ^[-a-zA-Z0-9_]+$
   */
  code?: string;
  /**
   * @minLength 1
   * @maxLength 100
   */
  label?: string;
}

export interface PatchedProductAssetRequest {
  file?: Blob;
  /**
   * Type of asset (image, video, document, etc.)
   * @minLength 1
   * @maxLength 20
   */
  asset_type?: string;
  /**
   * @maxLength 255
   * @nullable
   */
  name?: string | null;
  /**
   * Order in which assets are displayed
   * @minimum 0
   * @maximum 2147483647
   */
  order?: number;
  /** Is this the main asset for the product? */
  is_primary?: boolean;
  /**
   * MIME type of the file
   * @maxLength 100
   * @nullable
   */
  content_type?: string | null;
  /**
   * Size of the file in bytes
   * @minimum 0
   * @maximum 2147483647
   */
  file_size?: number;
  /** @nullable */
  uploaded_by?: number | null;
  tags?: string[];
}

/**
 * Serializer for Product model
 */
export interface PatchedProductRequest {
  /**
   * @minLength 1
   * @maxLength 255
   */
  name?: string;
  /**
   * @minLength 1
   * @maxLength 50
   */
  sku?: string;
  /** @nullable */
  description?: string | null;
  /**
   * @maxLength 100
   * @nullable
   */
  brand?: string | null;
  /**
   * @maxLength 100
   * @nullable
   */
  barcode?: string | null;
  tags?: string[];
  is_active?: boolean;
  is_archived?: boolean;
  /** @nullable */
  family?: number | null;
}

export type PatchedRoleRequestPermissions = { [key: string]: unknown };

export interface PatchedRoleRequest {
  /**
   * @minLength 1
   * @maxLength 50
   */
  name?: string;
  description?: string;
  permissions?: PatchedRoleRequestPermissions;
}

/**
 * Serializer for sales channels
 */
export interface PatchedSalesChannelRequest {
  /**
   * @minLength 1
   * @maxLength 50
   */
  code?: string;
  /**
   * @minLength 1
   * @maxLength 100
   */
  name?: string;
  /** @nullable */
  description?: string | null;
  is_active?: boolean;
}

export interface PriceType {
  readonly id: number;
  /**
   * @maxLength 32
   * @pattern ^[-a-zA-Z0-9_]+$
   */
  code: string;
  /** @maxLength 100 */
  label: string;
}

export interface PriceTypeRequest {
  /**
   * @minLength 1
   * @maxLength 32
   * @pattern ^[-a-zA-Z0-9_]+$
   */
  code: string;
  /**
   * @minLength 1
   * @maxLength 100
   */
  label: string;
}

/**
 * Serializer for Product model
 */
export interface Product {
  readonly id: number;
  /** @maxLength 255 */
  name: string;
  /** @maxLength 50 */
  sku: string;
  /** @nullable */
  description?: string | null;
  readonly prices: readonly ProductPrice[];
  readonly category: Category;
  readonly category_id: number;
  /**
   * @maxLength 100
   * @nullable
   */
  brand?: string | null;
  /**
   * @maxLength 100
   * @nullable
   */
  barcode?: string | null;
  tags?: string[];
  readonly attribute_values: string;
  is_active?: boolean;
  is_archived?: boolean;
  readonly created_at: string;
  readonly updated_at: string;
  readonly completeness_percent: string;
  readonly missing_fields: string;
  readonly assets: string;
  readonly primary_asset: string;
  /** @nullable */
  readonly organization: number | null;
  readonly created_by: string;
  /** @nullable */
  family?: number | null;
  readonly family_overrides: readonly ProductFamilyOverride[];
  readonly effective_attribute_groups: string;
  readonly category_name: string;
}

export interface ProductActivity {
  readonly id: number;
  type: string;
  user: string;
  timestamp: string;
  details: string;
}

export interface ProductAsset {
  readonly id: number;
  file: string;
  readonly file_url: string;
  /**
   * Type of asset (image, video, document, etc.)
   * @maxLength 20
   */
  asset_type?: string;
  /**
   * @maxLength 255
   * @nullable
   */
  name?: string | null;
  /**
   * Order in which assets are displayed
   * @minimum 0
   * @maximum 2147483647
   */
  order?: number;
  /** Is this the main asset for the product? */
  is_primary?: boolean;
  /**
   * MIME type of the file
   * @maxLength 100
   * @nullable
   */
  content_type?: string | null;
  /**
   * Size of the file in bytes
   * @minimum 0
   * @maximum 2147483647
   */
  file_size?: number;
  readonly file_size_formatted: string;
  /** @nullable */
  uploaded_by?: number | null;
  readonly uploaded_by_name: string;
  readonly uploaded_at: string;
  readonly product: number;
  tags?: string[];
}

export interface ProductAssetRequest {
  file: Blob;
  /**
   * Type of asset (image, video, document, etc.)
   * @minLength 1
   * @maxLength 20
   */
  asset_type?: string;
  /**
   * @maxLength 255
   * @nullable
   */
  name?: string | null;
  /**
   * Order in which assets are displayed
   * @minimum 0
   * @maximum 2147483647
   */
  order?: number;
  /** Is this the main asset for the product? */
  is_primary?: boolean;
  /**
   * MIME type of the file
   * @maxLength 100
   * @nullable
   */
  content_type?: string | null;
  /**
   * Size of the file in bytes
   * @minimum 0
   * @maximum 2147483647
   */
  file_size?: number;
  /** @nullable */
  uploaded_by?: number | null;
  tags?: string[];
}

/**
 * @nullable
 */
export type ProductEventPayload = { [key: string]: unknown } | null;

export interface ProductEvent {
  readonly id: number;
  /** @maxLength 50 */
  event_type: string;
  /** @maxLength 255 */
  summary: string;
  /** @nullable */
  payload?: ProductEventPayload;
  readonly created_at: string;
  readonly created_by_name: string;
}

/**
 * @nullable
 */
export type ProductEventRequestPayload = { [key: string]: unknown } | null;

export interface ProductEventRequest {
  /**
   * @minLength 1
   * @maxLength 50
   */
  event_type: string;
  /**
   * @minLength 1
   * @maxLength 255
   */
  summary: string;
  /** @nullable */
  payload?: ProductEventRequestPayload;
}

/**
 * Serializer for Product Family Override model
 */
export interface ProductFamilyOverride {
  readonly id: number;
  attribute_group: number;
  removed?: boolean;
}

/**
 * Serializer for Product Family Override model
 */
export interface ProductFamilyOverrideRequest {
  attribute_group: number;
  removed?: boolean;
}

/**
 * Serializer for product prices (unified payload)
 */
export interface ProductPrice {
  readonly id: number;
  price_type: string;
  readonly price_type_display: string;
  readonly label: string;
  readonly channel: SalesChannel;
  currency: string;
  /** @pattern ^-?\d{0,8}(?:\.\d{0,2})?$ */
  amount: string;
  valid_from?: string;
  /** @nullable */
  valid_to?: string | null;
  readonly created_at: string;
  readonly updated_at: string;
}

/**
 * Serializer for product prices (unified payload)
 */
export interface ProductPriceRequest {
  price_type: string;
  /** @nullable */
  channel_id?: number | null;
  /** @minLength 1 */
  currency: string;
  /** @pattern ^-?\d{0,8}(?:\.\d{0,2})?$ */
  amount: string;
  valid_from?: string;
  /** @nullable */
  valid_to?: string | null;
}

/**
 * Serializer for Product model
 */
export interface ProductRequest {
  /**
   * @minLength 1
   * @maxLength 255
   */
  name: string;
  /**
   * @minLength 1
   * @maxLength 50
   */
  sku: string;
  /** @nullable */
  description?: string | null;
  /**
   * @maxLength 100
   * @nullable
   */
  brand?: string | null;
  /**
   * @maxLength 100
   * @nullable
   */
  barcode?: string | null;
  tags?: string[];
  is_active?: boolean;
  is_archived?: boolean;
  /** @nullable */
  family?: number | null;
}

export interface ReportTheme {
  /**
   * @maxLength 64
   * @pattern ^[-a-zA-Z0-9_]+$
   */
  slug: string;
  /** @maxLength 128 */
  name: string;
  description?: string;
}

export type RolePermissions = { [key: string]: unknown };

export interface Role {
  readonly id: number;
  /** @maxLength 50 */
  name: string;
  description?: string;
  permissions?: RolePermissions;
}

export type RoleRequestPermissions = { [key: string]: unknown };

export interface RoleRequest {
  /**
   * @minLength 1
   * @maxLength 50
   */
  name: string;
  description?: string;
  permissions?: RoleRequestPermissions;
}

/**
 * Serializer for sales channels
 */
export interface SalesChannel {
  readonly id: number;
  /** @maxLength 50 */
  code: string;
  /** @maxLength 100 */
  name: string;
  /** @nullable */
  description?: string | null;
  is_active?: boolean;
}

/**
 * Serializer for sales channels
 */
export interface SalesChannelRequest {
  /**
   * @minLength 1
   * @maxLength 50
   */
  code: string;
  /**
   * @minLength 1
   * @maxLength 100
   */
  name: string;
  /** @nullable */
  description?: string | null;
  is_active?: boolean;
}

export interface TokenObtainPair {
  readonly access: string;
  readonly refresh: string;
}

export interface TokenObtainPairRequest {
  /** @minLength 1 */
  email: string;
  /** @minLength 1 */
  password: string;
}

export interface TokenRefresh {
  readonly access: string;
  refresh: string;
}

export interface TokenRefreshRequest {
  /** @minLength 1 */
  refresh: string;
}

export interface User {
  readonly id: number;
  /** @maxLength 254 */
  email: string;
  /** @maxLength 255 */
  name: string;
  readonly is_active: boolean;
  /** Designates whether the user can log into this admin site. */
  readonly is_staff: boolean;
  /** Designates that this user has all permissions without explicitly assigning them. */
  readonly is_superuser: boolean;
  readonly organization_id: string;
  readonly role: string;
  readonly avatar_url: string;
}

export type ImportsFieldSchemaRetrieveParams = {
  /**
   * Schema version (1 or 2)
   */
  v?: number;
};

/**
 * Unspecified response body
 */
export type ImportsFieldSchemaRetrieve200 = { [key: string]: unknown };

/**
 * Unspecified response body
 */
export type ImportsAttributeGroupsSchemaRetrieve200 = {
  [key: string]: unknown;
};

/**
 * Unspecified response body
 */
export type ImportsAttributesSchemaRetrieve200 = { [key: string]: unknown };

/**
 * Unspecified response body
 */
export type ImportsFamiliesSchemaRetrieve200 = { [key: string]: unknown };

export type ProductsListParams = {
  barcode?: string;
  brand?: string;
  category?: number;
  created_at_from?: string;
  created_at_to?: string;
  family?: number;
  is_active?: boolean;
  max_price?: number;
  min_price?: number;
  name?: string;
  /**
   * Which field to use when ordering the results.
   */
  ordering?: string;
  /**
   * A page number within the paginated result set.
   */
  page?: number;
  /**
   * Number of results to return per page.
   */
  page_size?: number;
  /**
   * A search term.
   */
  search?: string;
  sku?: string;
  tags?: string;
  updated_at_from?: string;
  updated_at_to?: string;
};

export type ProductsHistoryListParams = {
  /**
   * Which field to use when ordering the results.
   */
  ordering?: string;
  /**
   * A page number within the paginated result set.
   */
  page?: number;
};

export type AttributesListParams = {
  /**
   * Which field to use when ordering the results.
   */
  ordering?: string;
};

export type AttributeGroupsListParams = {
  /**
   * Which field to use when ordering the results.
   */
  ordering?: string;
};

export type CategoriesListParams = {
  /**
   * Which field to use when ordering the results.
   */
  ordering?: string;
  /**
   * A search term.
   */
  search?: string;
};

export type FamiliesListParams = {
  /**
   * Which field to use when ordering the results.
   */
  ordering?: string;
};

export type LocalesListParams = {
  /**
   * Which field to use when ordering the results.
   */
  ordering?: string;
  /**
   * A search term.
   */
  search?: string;
};

export type ChannelsListParams = {
  /**
   * Which field to use when ordering the results.
   */
  ordering?: string;
  /**
   * A search term.
   */
  search?: string;
};

export type ProductsAssetsListParams = {
  /**
   * Which field to use when ordering the results.
   */
  ordering?: string;
};

export type ProductsAssetBundlesListParams = {
  /**
   * Which field to use when ordering the results.
   */
  ordering?: string;
};

export type ProductsAttributesListParams = {
  /**
   * Which field to use when ordering the results.
   */
  ordering?: string;
};

export type ProductsAttributeGroupsListParams = {
  /**
   * Which field to use when ordering the results.
   */
  ordering?: string;
};

export type ProductsActivitiesListParams = {
  /**
   * Which field to use when ordering the results.
   */
  ordering?: string;
};

export type ProductsFamilyOverridesListParams = {
  /**
   * Which field to use when ordering the results.
   */
  ordering?: string;
};

export type ProductsOverrideGroupCreateParams = {
  /**
   * Product ID
   */
  product_id: number;
};

export type ProductsOverrideGroupCreateBody = {
  attribute_group: number;
  removed: boolean;
};

export type ImportsListParams = {
  /**
   * Which field to use when ordering the results.
   */
  ordering?: string;
};

export type AttributeGroupsImportListParams = {
  /**
   * Which field to use when ordering the results.
   */
  ordering?: string;
};

export type AttributesImportListParams = {
  /**
   * Which field to use when ordering the results.
   */
  ordering?: string;
};

export type FamiliesImportListParams = {
  /**
   * Which field to use when ordering the results.
   */
  ordering?: string;
};

export type FieldSchemaRetrieveParams = {
  /**
   * Schema version (1 or 2)
   */
  v?: number;
};

/**
 * Unspecified response body
 */
export type FieldSchemaRetrieve200 = { [key: string]: unknown };

/**
 * Unspecified response body
 */
export type AttributeGroupsSchemaRetrieve200 = { [key: string]: unknown };

/**
 * Unspecified response body
 */
export type AttributesSchemaRetrieve200 = { [key: string]: unknown };

/**
 * Unspecified response body
 */
export type FamiliesSchemaRetrieve200 = { [key: string]: unknown };

export type ReportsThemesListParams = {
  /**
   * Which field to use when ordering the results.
   */
  ordering?: string;
};

export type OrgsRolesListParams = {
  /**
   * Which field to use when ordering the results.
   */
  ordering?: string;
};

export type OrgsMembershipsListParams = {
  /**
   * Which field to use when ordering the results.
   */
  ordering?: string;
};

export type OrgsAuditListParams = {
  /**
   * Which field to use when ordering the results.
   */
  ordering?: string;
};

export type CurrenciesListParams = {
  /**
   * Which field to use when ordering the results.
   */
  ordering?: string;
};

export type PriceTypesListParams = {
  /**
   * Which field to use when ordering the results.
   */
  ordering?: string;
};

export type UsersListParams = {
  /**
   * Which field to use when ordering the results.
   */
  ordering?: string;
};

/**
 * This is the base client to use for interacting with the API.
 */
export class KernLogicAPIClient {
  private cleanBaseUrl: string;
  private commonRequestParameters: Params;

  constructor(clientOptions: {
    baseUrl: string;
    commonRequestParameters?: Params;
  }) {
    this.cleanBaseUrl = clientOptions.baseUrl.replace(/\/+$/, "");

    this.commonRequestParameters = clientOptions.commonRequestParameters || {};
  }

  /**
 * Takes a set of user credentials and returns an access and refresh JSON web
token pair to prove the authentication of those credentials.
 */
  tokenCreate(
    tokenObtainPairRequest: TokenObtainPairRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: TokenObtainPair;
  } {
    const url = new URL(this.cleanBaseUrl + `/token/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "POST",
      url.toString(),
      JSON.stringify(tokenObtainPairRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * Takes a refresh type JSON web token and returns an access type JSON web
token if the refresh token is valid.
 */
  tokenRefreshCreate(
    tokenRefreshRequest: TokenRefreshRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: TokenRefresh;
  } {
    const url = new URL(this.cleanBaseUrl + `/token/refresh/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "POST",
      url.toString(),
      JSON.stringify(tokenRefreshRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  orgsRetrieve(
    orgId: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/orgs/${orgId}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Update organization settings including default_locale and default_channel
   */
  orgsPartialUpdate(
    orgId: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/orgs/${orgId}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "PATCH",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  organizationsRetrieve(
    orgId: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/organizations/${orgId}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Update organization settings including default_locale and default_channel
   */
  organizationsPartialUpdate(
    orgId: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/organizations/${orgId}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "PATCH",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * Handle membership avatar uploads, viewing, and deletion.

- GET: Return the avatar URL
- POST: Upload a new avatar
- DELETE: Remove the existing avatar
 */
  orgsMembershipsAvatarRetrieve(
    orgId: number,
    membershipId: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: void;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/orgs/${orgId}/memberships/${membershipId}/avatar/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * Handle membership avatar uploads, viewing, and deletion.

- GET: Return the avatar URL
- POST: Upload a new avatar
- DELETE: Remove the existing avatar
 */
  orgsMembershipsAvatarDestroy(
    orgId: number,
    membershipId: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: void;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/orgs/${orgId}/memberships/${membershipId}/avatar/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "DELETE",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * Handle membership avatar uploads, viewing, and deletion.

- GET: Return the avatar URL
- POST: Upload a new avatar
- DELETE: Remove the existing avatar
 */
  orgsMembershipsAvatarCreate(
    orgId: number,
    membershipId: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: void;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/orgs/${orgId}/memberships/${membershipId}/avatar/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "POST",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Direct function-based view for exporting completeness report
   */
  analyticsCompletenessExportRetrieve(requestParameters?: Params): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/analytics/completeness-export/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Direct function-based view for exporting readiness report
   */
  analyticsReadinessExportRetrieve(requestParameters?: Params): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/analytics/readiness-export/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Direct function-based view for exporting enrichment velocity report
   */
  analyticsEnrichmentVelocityExportRetrieve(requestParameters?: Params): {
    response: Response;
    data: void;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/analytics/enrichment-velocity-export/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Direct function-based view for exporting localization quality report
   */
  analyticsLocalizationQualityExportRetrieve(requestParameters?: Params): {
    response: Response;
    data: void;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/analytics/localization-quality-export/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Direct function-based view for exporting change history report
   */
  analyticsChangeHistoryExportRetrieve(requestParameters?: Params): {
    response: Response;
    data: void;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/analytics/change-history-export/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Get the canonical schema of importable fields
   */
  importsFieldSchemaRetrieve(
    params?: ImportsFieldSchemaRetrieveParams,
    requestParameters?: Params,
  ): {
    response: Response;
    data: ImportsFieldSchemaRetrieve200;
  } {
    const url = new URL(
      this.cleanBaseUrl +
        `/imports/field-schema/` +
        `?${new URLSearchParams(params).toString()}`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("GET", url.toString(), undefined, {
      ...mergedRequestParameters,
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Get the schema for attribute group import fields
   */
  importsAttributeGroupsSchemaRetrieve(requestParameters?: Params): {
    response: Response;
    data: ImportsAttributeGroupsSchemaRetrieve200;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/imports/attribute-groups-schema/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Get the schema for attribute import fields
   */
  importsAttributesSchemaRetrieve(requestParameters?: Params): {
    response: Response;
    data: ImportsAttributesSchemaRetrieve200;
  } {
    const url = new URL(this.cleanBaseUrl + `/imports/attributes-schema/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Get the schema for family import fields
   */
  importsFamiliesSchemaRetrieve(requestParameters?: Params): {
    response: Response;
    data: ImportsFamiliesSchemaRetrieve200;
  } {
    const url = new URL(this.cleanBaseUrl + `/imports/families-schema/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Override list method to use the full ProductSerializer so that the list endpoint returns nested category data.
   */
  productsList(
    params?: ProductsListParams,
    requestParameters?: Params,
  ): {
    response: Response;
    data: PaginatedProductList;
  } {
    const url = new URL(
      this.cleanBaseUrl +
        `/products/` +
        `?${new URLSearchParams(params).toString()}`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("GET", url.toString(), undefined, {
      ...mergedRequestParameters,
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Create a new product
   */
  productsCreate(
    productRequest: ProductRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Product;
  } {
    const formData = new FormData();
    formData.append(`name`, productRequest.name);
    formData.append(`sku`, productRequest.sku);
    if (
      productRequest.description !== undefined &&
      productRequest.description !== null
    ) {
      formData.append(`description`, productRequest.description);
    }
    if (productRequest.brand !== undefined && productRequest.brand !== null) {
      formData.append(`brand`, productRequest.brand);
    }
    if (
      productRequest.barcode !== undefined &&
      productRequest.barcode !== null
    ) {
      formData.append(`barcode`, productRequest.barcode);
    }
    if (productRequest.tags !== undefined) {
      productRequest.tags.forEach((value) => formData.append(`tags`, value));
    }
    if (productRequest.is_active !== undefined) {
      formData.append(`is_active`, productRequest.is_active.toString());
    }
    if (productRequest.is_archived !== undefined) {
      formData.append(`is_archived`, productRequest.is_archived.toString());
    }
    if (productRequest.family !== undefined && productRequest.family !== null) {
      formData.append(`family`, productRequest.family.toString());
    }

    const url = new URL(this.cleanBaseUrl + `/products/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("POST", url.toString(), formData.body(), {
      ...mergedRequestParameters,
      headers: {
        ...mergedRequestParameters?.headers,
        "Content-Type": "multipart/form-data; boundary=" + formData.boundary,
      },
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Return a list of unique brands for dropdown menus.
   */
  productsBrandsRetrieve(requestParameters?: Params): {
    response: Response;
    data: Product;
  } {
    const url = new URL(this.cleanBaseUrl + `/products/brands/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Create multiple products at once from a CSV upload or bulk input.
   */
  productsBulkCreateCreate(
    productRequest: ProductRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Product;
  } {
    const formData = new FormData();
    formData.append(`name`, productRequest.name);
    formData.append(`sku`, productRequest.sku);
    if (
      productRequest.description !== undefined &&
      productRequest.description !== null
    ) {
      formData.append(`description`, productRequest.description);
    }
    if (productRequest.brand !== undefined && productRequest.brand !== null) {
      formData.append(`brand`, productRequest.brand);
    }
    if (
      productRequest.barcode !== undefined &&
      productRequest.barcode !== null
    ) {
      formData.append(`barcode`, productRequest.barcode);
    }
    if (productRequest.tags !== undefined) {
      productRequest.tags.forEach((value) => formData.append(`tags`, value));
    }
    if (productRequest.is_active !== undefined) {
      formData.append(`is_active`, productRequest.is_active.toString());
    }
    if (productRequest.is_archived !== undefined) {
      formData.append(`is_archived`, productRequest.is_archived.toString());
    }
    if (productRequest.family !== undefined && productRequest.family !== null) {
      formData.append(`family`, productRequest.family.toString());
    }

    const url = new URL(this.cleanBaseUrl + `/products/bulk_create/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("POST", url.toString(), formData.body(), {
      ...mergedRequestParameters,
      headers: {
        ...mergedRequestParameters?.headers,
        "Content-Type": "multipart/form-data; boundary=" + formData.boundary,
      },
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * Permanently delete multiple products at once.
Expects: ids (list of product IDs)
 */
  productsBulkDeleteCreate(
    productRequest: ProductRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Product;
  } {
    const formData = new FormData();
    formData.append(`name`, productRequest.name);
    formData.append(`sku`, productRequest.sku);
    if (
      productRequest.description !== undefined &&
      productRequest.description !== null
    ) {
      formData.append(`description`, productRequest.description);
    }
    if (productRequest.brand !== undefined && productRequest.brand !== null) {
      formData.append(`brand`, productRequest.brand);
    }
    if (
      productRequest.barcode !== undefined &&
      productRequest.barcode !== null
    ) {
      formData.append(`barcode`, productRequest.barcode);
    }
    if (productRequest.tags !== undefined) {
      productRequest.tags.forEach((value) => formData.append(`tags`, value));
    }
    if (productRequest.is_active !== undefined) {
      formData.append(`is_active`, productRequest.is_active.toString());
    }
    if (productRequest.is_archived !== undefined) {
      formData.append(`is_archived`, productRequest.is_archived.toString());
    }
    if (productRequest.family !== undefined && productRequest.family !== null) {
      formData.append(`family`, productRequest.family.toString());
    }

    const url = new URL(this.cleanBaseUrl + `/products/bulk_delete/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("POST", url.toString(), formData.body(), {
      ...mergedRequestParameters,
      headers: {
        ...mergedRequestParameters?.headers,
        "Content-Type": "multipart/form-data; boundary=" + formData.boundary,
      },
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * Update a field for multiple products at once.
Expects: ids (list of product IDs), field (string), and the value to set.
For tags, expects 'tags' array instead of a single value.
 */
  productsBulkUpdateCreate(
    productRequest: ProductRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Product;
  } {
    const formData = new FormData();
    formData.append(`name`, productRequest.name);
    formData.append(`sku`, productRequest.sku);
    if (
      productRequest.description !== undefined &&
      productRequest.description !== null
    ) {
      formData.append(`description`, productRequest.description);
    }
    if (productRequest.brand !== undefined && productRequest.brand !== null) {
      formData.append(`brand`, productRequest.brand);
    }
    if (
      productRequest.barcode !== undefined &&
      productRequest.barcode !== null
    ) {
      formData.append(`barcode`, productRequest.barcode);
    }
    if (productRequest.tags !== undefined) {
      productRequest.tags.forEach((value) => formData.append(`tags`, value));
    }
    if (productRequest.is_active !== undefined) {
      formData.append(`is_active`, productRequest.is_active.toString());
    }
    if (productRequest.is_archived !== undefined) {
      formData.append(`is_archived`, productRequest.is_archived.toString());
    }
    if (productRequest.family !== undefined && productRequest.family !== null) {
      formData.append(`family`, productRequest.family.toString());
    }

    const url = new URL(this.cleanBaseUrl + `/products/bulk_update/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("POST", url.toString(), formData.body(), {
      ...mergedRequestParameters,
      headers: {
        ...mergedRequestParameters?.headers,
        "Content-Type": "multipart/form-data; boundary=" + formData.boundary,
      },
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * GET: Return a list of unique categories for dropdown menus.
POST: Create a new category by adding it directly to the Category model.

This is a legacy endpoint maintained for backward compatibility.
New clients should use the dedicated CategoryViewSet instead.
 */
  productsCategoriesRetrieve(requestParameters?: Params): {
    response: Response;
    data: Product;
  } {
    const url = new URL(this.cleanBaseUrl + `/products/categories/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * GET: Return a list of unique categories for dropdown menus.
POST: Create a new category by adding it directly to the Category model.

This is a legacy endpoint maintained for backward compatibility.
New clients should use the dedicated CategoryViewSet instead.
 */
  productsCategoriesCreate(
    productRequest: ProductRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Product;
  } {
    const formData = new FormData();
    formData.append(`name`, productRequest.name);
    formData.append(`sku`, productRequest.sku);
    if (
      productRequest.description !== undefined &&
      productRequest.description !== null
    ) {
      formData.append(`description`, productRequest.description);
    }
    if (productRequest.brand !== undefined && productRequest.brand !== null) {
      formData.append(`brand`, productRequest.brand);
    }
    if (
      productRequest.barcode !== undefined &&
      productRequest.barcode !== null
    ) {
      formData.append(`barcode`, productRequest.barcode);
    }
    if (productRequest.tags !== undefined) {
      productRequest.tags.forEach((value) => formData.append(`tags`, value));
    }
    if (productRequest.is_active !== undefined) {
      formData.append(`is_active`, productRequest.is_active.toString());
    }
    if (productRequest.is_archived !== undefined) {
      formData.append(`is_archived`, productRequest.is_archived.toString());
    }
    if (productRequest.family !== undefined && productRequest.family !== null) {
      formData.append(`family`, productRequest.family.toString());
    }

    const url = new URL(this.cleanBaseUrl + `/products/categories/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("POST", url.toString(), formData.body(), {
      ...mergedRequestParameters,
      headers: {
        ...mergedRequestParameters?.headers,
        "Content-Type": "multipart/form-data; boundary=" + formData.boundary,
      },
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Remove all category placeholder products (created when adding categories)
   */
  productsCleanupCategoryPlaceholdersCreate(
    productRequest: ProductRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Product;
  } {
    const formData = new FormData();
    formData.append(`name`, productRequest.name);
    formData.append(`sku`, productRequest.sku);
    if (
      productRequest.description !== undefined &&
      productRequest.description !== null
    ) {
      formData.append(`description`, productRequest.description);
    }
    if (productRequest.brand !== undefined && productRequest.brand !== null) {
      formData.append(`brand`, productRequest.brand);
    }
    if (
      productRequest.barcode !== undefined &&
      productRequest.barcode !== null
    ) {
      formData.append(`barcode`, productRequest.barcode);
    }
    if (productRequest.tags !== undefined) {
      productRequest.tags.forEach((value) => formData.append(`tags`, value));
    }
    if (productRequest.is_active !== undefined) {
      formData.append(`is_active`, productRequest.is_active.toString());
    }
    if (productRequest.is_archived !== undefined) {
      formData.append(`is_archived`, productRequest.is_archived.toString());
    }
    if (productRequest.family !== undefined && productRequest.family !== null) {
      formData.append(`family`, productRequest.family.toString());
    }

    const url = new URL(
      this.cleanBaseUrl + `/products/cleanup_category_placeholders/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("POST", url.toString(), formData.body(), {
      ...mergedRequestParameters,
      headers: {
        ...mergedRequestParameters?.headers,
        "Content-Type": "multipart/form-data; boundary=" + formData.boundary,
      },
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * GET: List all sales channels
POST: Create a new sales channel
 */
  productsSalesChannelsRetrieve(requestParameters?: Params): {
    response: Response;
    data: Product;
  } {
    const url = new URL(this.cleanBaseUrl + `/products/sales-channels/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * GET: List all sales channels
POST: Create a new sales channel
 */
  productsSalesChannelsCreate(
    productRequest: ProductRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Product;
  } {
    const formData = new FormData();
    formData.append(`name`, productRequest.name);
    formData.append(`sku`, productRequest.sku);
    if (
      productRequest.description !== undefined &&
      productRequest.description !== null
    ) {
      formData.append(`description`, productRequest.description);
    }
    if (productRequest.brand !== undefined && productRequest.brand !== null) {
      formData.append(`brand`, productRequest.brand);
    }
    if (
      productRequest.barcode !== undefined &&
      productRequest.barcode !== null
    ) {
      formData.append(`barcode`, productRequest.barcode);
    }
    if (productRequest.tags !== undefined) {
      productRequest.tags.forEach((value) => formData.append(`tags`, value));
    }
    if (productRequest.is_active !== undefined) {
      formData.append(`is_active`, productRequest.is_active.toString());
    }
    if (productRequest.is_archived !== undefined) {
      formData.append(`is_archived`, productRequest.is_archived.toString());
    }
    if (productRequest.family !== undefined && productRequest.family !== null) {
      formData.append(`family`, productRequest.family.toString());
    }

    const url = new URL(this.cleanBaseUrl + `/products/sales-channels/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("POST", url.toString(), formData.body(), {
      ...mergedRequestParameters,
      headers: {
        ...mergedRequestParameters?.headers,
        "Content-Type": "multipart/form-data; boundary=" + formData.boundary,
      },
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Return basic statistics about products
   */
  productsStatsRetrieve(requestParameters?: Params): {
    response: Response;
    data: Product;
  } {
    const url = new URL(this.cleanBaseUrl + `/products/stats/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * GET: Return a list of unique tags from all products.
POST: Create a new tag by adding it to a "tag repository" product or returning an existing tag.
 */
  productsTagsRetrieve(requestParameters?: Params): {
    response: Response;
    data: Product;
  } {
    const url = new URL(this.cleanBaseUrl + `/products/tags/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * GET: Return a list of unique tags from all products.
POST: Create a new tag by adding it to a "tag repository" product or returning an existing tag.
 */
  productsTagsCreate(
    productRequest: ProductRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Product;
  } {
    const formData = new FormData();
    formData.append(`name`, productRequest.name);
    formData.append(`sku`, productRequest.sku);
    if (
      productRequest.description !== undefined &&
      productRequest.description !== null
    ) {
      formData.append(`description`, productRequest.description);
    }
    if (productRequest.brand !== undefined && productRequest.brand !== null) {
      formData.append(`brand`, productRequest.brand);
    }
    if (
      productRequest.barcode !== undefined &&
      productRequest.barcode !== null
    ) {
      formData.append(`barcode`, productRequest.barcode);
    }
    if (productRequest.tags !== undefined) {
      productRequest.tags.forEach((value) => formData.append(`tags`, value));
    }
    if (productRequest.is_active !== undefined) {
      formData.append(`is_active`, productRequest.is_active.toString());
    }
    if (productRequest.is_archived !== undefined) {
      formData.append(`is_archived`, productRequest.is_archived.toString());
    }
    if (productRequest.family !== undefined && productRequest.family !== null) {
      formData.append(`family`, productRequest.family.toString());
    }

    const url = new URL(this.cleanBaseUrl + `/products/tags/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("POST", url.toString(), formData.body(), {
      ...mergedRequestParameters,
      headers: {
        ...mergedRequestParameters?.headers,
        "Content-Type": "multipart/form-data; boundary=" + formData.boundary,
      },
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * API endpoint for managing product data.
   */
  productsPartialUpdate(
    id: number,
    patchedProductRequest: PatchedProductRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Product;
  } {
    const formData = new FormData();
    if (patchedProductRequest.name !== undefined) {
      formData.append(`name`, patchedProductRequest.name);
    }
    if (patchedProductRequest.sku !== undefined) {
      formData.append(`sku`, patchedProductRequest.sku);
    }
    if (
      patchedProductRequest.description !== undefined &&
      patchedProductRequest.description !== null
    ) {
      formData.append(`description`, patchedProductRequest.description);
    }
    if (
      patchedProductRequest.brand !== undefined &&
      patchedProductRequest.brand !== null
    ) {
      formData.append(`brand`, patchedProductRequest.brand);
    }
    if (
      patchedProductRequest.barcode !== undefined &&
      patchedProductRequest.barcode !== null
    ) {
      formData.append(`barcode`, patchedProductRequest.barcode);
    }
    if (patchedProductRequest.tags !== undefined) {
      patchedProductRequest.tags.forEach((value) =>
        formData.append(`tags`, value),
      );
    }
    if (patchedProductRequest.is_active !== undefined) {
      formData.append(`is_active`, patchedProductRequest.is_active.toString());
    }
    if (patchedProductRequest.is_archived !== undefined) {
      formData.append(
        `is_archived`,
        patchedProductRequest.is_archived.toString(),
      );
    }
    if (
      patchedProductRequest.family !== undefined &&
      patchedProductRequest.family !== null
    ) {
      formData.append(`family`, patchedProductRequest.family.toString());
    }

    const url = new URL(this.cleanBaseUrl + `/products/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("PATCH", url.toString(), formData.body(), {
      ...mergedRequestParameters,
      headers: {
        ...mergedRequestParameters?.headers,
        "Content-Type": "multipart/form-data; boundary=" + formData.boundary,
      },
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * API endpoint for managing product data.
   */
  productsRetrieve(
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Product;
  } {
    const url = new URL(this.cleanBaseUrl + `/products/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Soft delete by setting is_archived=True or permanently delete if requested
   */
  productsDestroy(
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/products/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "DELETE",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Add a related product to this product
   */
  productsRelatedAddCreate(
    id: number,
    productRequest: ProductRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Product;
  } {
    const formData = new FormData();
    formData.append(`name`, productRequest.name);
    formData.append(`sku`, productRequest.sku);
    if (
      productRequest.description !== undefined &&
      productRequest.description !== null
    ) {
      formData.append(`description`, productRequest.description);
    }
    if (productRequest.brand !== undefined && productRequest.brand !== null) {
      formData.append(`brand`, productRequest.brand);
    }
    if (
      productRequest.barcode !== undefined &&
      productRequest.barcode !== null
    ) {
      formData.append(`barcode`, productRequest.barcode);
    }
    if (productRequest.tags !== undefined) {
      productRequest.tags.forEach((value) => formData.append(`tags`, value));
    }
    if (productRequest.is_active !== undefined) {
      formData.append(`is_active`, productRequest.is_active.toString());
    }
    if (productRequest.is_archived !== undefined) {
      formData.append(`is_archived`, productRequest.is_archived.toString());
    }
    if (productRequest.family !== undefined && productRequest.family !== null) {
      formData.append(`family`, productRequest.family.toString());
    }

    const url = new URL(this.cleanBaseUrl + `/products/${id}/related-add/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("POST", url.toString(), formData.body(), {
      ...mergedRequestParameters,
      headers: {
        ...mergedRequestParameters?.headers,
        "Content-Type": "multipart/form-data; boundary=" + formData.boundary,
      },
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * Return only the explicitly related products through ProductRelation model.
Does not include category matches.
 */
  productsExplicitRelationsRetrieve(
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Product;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/products/${id}/explicit-relations/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * GET, PATCH, DELETE operations for a specific price
   */
  productsPricesPartialUpdate(
    id: number,
    priceId: string,
    patchedProductRequest: PatchedProductRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Product;
  } {
    const formData = new FormData();
    if (patchedProductRequest.name !== undefined) {
      formData.append(`name`, patchedProductRequest.name);
    }
    if (patchedProductRequest.sku !== undefined) {
      formData.append(`sku`, patchedProductRequest.sku);
    }
    if (
      patchedProductRequest.description !== undefined &&
      patchedProductRequest.description !== null
    ) {
      formData.append(`description`, patchedProductRequest.description);
    }
    if (
      patchedProductRequest.brand !== undefined &&
      patchedProductRequest.brand !== null
    ) {
      formData.append(`brand`, patchedProductRequest.brand);
    }
    if (
      patchedProductRequest.barcode !== undefined &&
      patchedProductRequest.barcode !== null
    ) {
      formData.append(`barcode`, patchedProductRequest.barcode);
    }
    if (patchedProductRequest.tags !== undefined) {
      patchedProductRequest.tags.forEach((value) =>
        formData.append(`tags`, value),
      );
    }
    if (patchedProductRequest.is_active !== undefined) {
      formData.append(`is_active`, patchedProductRequest.is_active.toString());
    }
    if (patchedProductRequest.is_archived !== undefined) {
      formData.append(
        `is_archived`,
        patchedProductRequest.is_archived.toString(),
      );
    }
    if (
      patchedProductRequest.family !== undefined &&
      patchedProductRequest.family !== null
    ) {
      formData.append(`family`, patchedProductRequest.family.toString());
    }

    const url = new URL(
      this.cleanBaseUrl + `/products/${id}/prices/${priceId}/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("PATCH", url.toString(), formData.body(), {
      ...mergedRequestParameters,
      headers: {
        ...mergedRequestParameters?.headers,
        "Content-Type": "multipart/form-data; boundary=" + formData.boundary,
      },
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * GET, PATCH, DELETE operations for a specific price
   */
  productsPricesRetrieve2(
    id: number,
    priceId: string,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Product;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/products/${id}/prices/${priceId}/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * GET, PATCH, DELETE operations for a specific price
   */
  productsPricesDestroy(
    id: number,
    priceId: string,
    requestParameters?: Params,
  ): {
    response: Response;
    data: void;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/products/${id}/prices/${priceId}/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "DELETE",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Update or delete a related product relationship
   */
  productsRelatedPartialUpdate(
    id: number,
    relatedId: string,
    patchedProductRequest: PatchedProductRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Product;
  } {
    const formData = new FormData();
    if (patchedProductRequest.name !== undefined) {
      formData.append(`name`, patchedProductRequest.name);
    }
    if (patchedProductRequest.sku !== undefined) {
      formData.append(`sku`, patchedProductRequest.sku);
    }
    if (
      patchedProductRequest.description !== undefined &&
      patchedProductRequest.description !== null
    ) {
      formData.append(`description`, patchedProductRequest.description);
    }
    if (
      patchedProductRequest.brand !== undefined &&
      patchedProductRequest.brand !== null
    ) {
      formData.append(`brand`, patchedProductRequest.brand);
    }
    if (
      patchedProductRequest.barcode !== undefined &&
      patchedProductRequest.barcode !== null
    ) {
      formData.append(`barcode`, patchedProductRequest.barcode);
    }
    if (patchedProductRequest.tags !== undefined) {
      patchedProductRequest.tags.forEach((value) =>
        formData.append(`tags`, value),
      );
    }
    if (patchedProductRequest.is_active !== undefined) {
      formData.append(`is_active`, patchedProductRequest.is_active.toString());
    }
    if (patchedProductRequest.is_archived !== undefined) {
      formData.append(
        `is_archived`,
        patchedProductRequest.is_archived.toString(),
      );
    }
    if (
      patchedProductRequest.family !== undefined &&
      patchedProductRequest.family !== null
    ) {
      formData.append(`family`, patchedProductRequest.family.toString());
    }

    const url = new URL(
      this.cleanBaseUrl + `/products/${id}/related/${relatedId}/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("PATCH", url.toString(), formData.body(), {
      ...mergedRequestParameters,
      headers: {
        ...mergedRequestParameters?.headers,
        "Content-Type": "multipart/form-data; boundary=" + formData.boundary,
      },
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Update or delete a related product relationship
   */
  productsRelatedDestroy(
    id: number,
    relatedId: string,
    requestParameters?: Params,
  ): {
    response: Response;
    data: void;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/products/${id}/related/${relatedId}/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "DELETE",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * GET: List prices for a product
POST: Create a new price for a product
 */
  productsPricesRetrieve(
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Product;
  } {
    const url = new URL(this.cleanBaseUrl + `/products/${id}/prices/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * GET: List prices for a product
POST: Create a new price for a product
 */
  productsPricesCreate(
    id: number,
    productRequest: ProductRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Product;
  } {
    const formData = new FormData();
    formData.append(`name`, productRequest.name);
    formData.append(`sku`, productRequest.sku);
    if (
      productRequest.description !== undefined &&
      productRequest.description !== null
    ) {
      formData.append(`description`, productRequest.description);
    }
    if (productRequest.brand !== undefined && productRequest.brand !== null) {
      formData.append(`brand`, productRequest.brand);
    }
    if (
      productRequest.barcode !== undefined &&
      productRequest.barcode !== null
    ) {
      formData.append(`barcode`, productRequest.barcode);
    }
    if (productRequest.tags !== undefined) {
      productRequest.tags.forEach((value) => formData.append(`tags`, value));
    }
    if (productRequest.is_active !== undefined) {
      formData.append(`is_active`, productRequest.is_active.toString());
    }
    if (productRequest.is_archived !== undefined) {
      formData.append(`is_archived`, productRequest.is_archived.toString());
    }
    if (productRequest.family !== undefined && productRequest.family !== null) {
      formData.append(`family`, productRequest.family.toString());
    }

    const url = new URL(this.cleanBaseUrl + `/products/${id}/prices/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("POST", url.toString(), formData.body(), {
      ...mergedRequestParameters,
      headers: {
        ...mergedRequestParameters?.headers,
        "Content-Type": "multipart/form-data; boundary=" + formData.boundary,
      },
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Alias for related_products action to maintain compatibility with frontend.
   */
  productsRelatedListRetrieve(
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Product;
  } {
    const url = new URL(this.cleanBaseUrl + `/products/${id}/related-list/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * Return a list of related products based on the same category.
Excludes the source product from the results.
 */
  productsRelatedProductsRetrieve(
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Product;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/products/${id}/related_products/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * API endpoint for managing product data.
   */
  productsSetPrimaryCreate(
    id: number,
    productRequest: ProductRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Product;
  } {
    const formData = new FormData();
    formData.append(`name`, productRequest.name);
    formData.append(`sku`, productRequest.sku);
    if (
      productRequest.description !== undefined &&
      productRequest.description !== null
    ) {
      formData.append(`description`, productRequest.description);
    }
    if (productRequest.brand !== undefined && productRequest.brand !== null) {
      formData.append(`brand`, productRequest.brand);
    }
    if (
      productRequest.barcode !== undefined &&
      productRequest.barcode !== null
    ) {
      formData.append(`barcode`, productRequest.barcode);
    }
    if (productRequest.tags !== undefined) {
      productRequest.tags.forEach((value) => formData.append(`tags`, value));
    }
    if (productRequest.is_active !== undefined) {
      formData.append(`is_active`, productRequest.is_active.toString());
    }
    if (productRequest.is_archived !== undefined) {
      formData.append(`is_archived`, productRequest.is_archived.toString());
    }
    if (productRequest.family !== undefined && productRequest.family !== null) {
      formData.append(`family`, productRequest.family.toString());
    }

    const url = new URL(this.cleanBaseUrl + `/products/${id}/set_primary/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("POST", url.toString(), formData.body(), {
      ...mergedRequestParameters,
      headers: {
        ...mergedRequestParameters?.headers,
        "Content-Type": "multipart/form-data; boundary=" + formData.boundary,
      },
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Return recent activity data (limit 10)
   */
  dashboardActivityRetrieve(requestParameters?: Params): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/dashboard/activity/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Start a background process to auto-enrich required attributes
   */
  dashboardAutoEnrichCreate(requestParameters?: Params): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/dashboard/auto-enrich/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "POST",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Return completeness percentage for each product family
   */
  dashboardFamilyCompletenessRetrieve(requestParameters?: Params): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/dashboard/family-completeness/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Return the top 5 incomplete products
   */
  dashboardIncompleteProductsRetrieve(requestParameters?: Params): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/dashboard/incomplete-products/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Return inventory value trend data for the specified time range
   */
  dashboardInventoryTrendRetrieve(requestParameters?: Params): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/dashboard/inventory-trend/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Return information about required attributes across all families
   */
  dashboardRequiredAttributesRetrieve(requestParameters?: Params): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/dashboard/required-attributes/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * Return dashboard summary data:
- KPI numbers (total products, inventory value, inactive products, team members)
- Data completeness percentage (calculated using FactProductAttribute, same as analytics endpoint)
- Most missing fields (calculated from fact table where possible)
- Product status counts

NOTE: This implementation now uses the FactProductAttribute.completed field for
completeness calculation, matching how the /api/analytics/completeness/ endpoint
calculates overall completeness. This ensures consistent metrics across the application.
 */
  dashboardSummaryRetrieve(requestParameters?: Params): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/dashboard/summary/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Auto-enrich a specific attribute
   */
  dashboardEnrichCreate(
    id: string,
    attributeName: string,
    requestParameters?: Params,
  ): {
    response: Response;
    data: void;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/dashboard/${id}/enrich/${attributeName}/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "POST",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * A mixin that filters querysets by the user's organization.

This mixin should be applied to viewsets that need to filter
models that have an organization foreign key.
 */
  productsHistoryList(
    productPk: string,
    params?: ProductsHistoryListParams,
    requestParameters?: Params,
  ): {
    response: Response;
    data: PaginatedProductEventList;
  } {
    const url = new URL(
      this.cleanBaseUrl +
        `/products/${productPk}/history/` +
        `?${new URLSearchParams(params).toString()}`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("GET", url.toString(), undefined, {
      ...mergedRequestParameters,
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * Rollback a specific product field to its previous value from a history event.

Expects a JSON payload with a 'field' parameter specifying which field to rollback.
Returns the updated product after the rollback operation.

Example:
    POST /api/products/42/history/123/rollback/
    Body: { "field": "price" }
 */
  productsHistoryRollbackCreate(
    productPk: string,
    id: number,
    productEventRequest: ProductEventRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: ProductEvent;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/products/${productPk}/history/${id}/rollback/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "POST",
      url.toString(),
      JSON.stringify(productEventRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  attributeSetsRetrieve(
    id: string,
    requestParameters?: Params,
  ): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/attribute-sets/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Returns attributes for the current organization.
   * @summary List all attributes
   */
  attributesList(
    params?: AttributesListParams,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Attribute[];
  } {
    const url = new URL(
      this.cleanBaseUrl +
        `/attributes/` +
        `?${new URLSearchParams(params).toString()}`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("GET", url.toString(), undefined, {
      ...mergedRequestParameters,
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Create a new attribute for the current organization. Staff only.
   * @summary Create a new attribute
   */
  attributesCreate(
    attributeRequest: AttributeRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Attribute;
  } {
    const url = new URL(this.cleanBaseUrl + `/attributes/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "POST",
      url.toString(),
      JSON.stringify(attributeRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Partially update an existing attribute. Staff only.
   * @summary Partially update an attribute
   */
  attributesPartialUpdate(
    id: number,
    patchedAttributeRequest: PatchedAttributeRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Attribute;
  } {
    const url = new URL(this.cleanBaseUrl + `/attributes/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "PATCH",
      url.toString(),
      JSON.stringify(patchedAttributeRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Returns details of a specific attribute.
   * @summary Get a specific attribute
   */
  attributesRetrieve(
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Attribute;
  } {
    const url = new URL(this.cleanBaseUrl + `/attributes/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Update an existing attribute. Staff only.
   * @summary Update an attribute
   */
  attributesUpdate(
    id: number,
    attributeRequest: AttributeRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Attribute;
  } {
    const url = new URL(this.cleanBaseUrl + `/attributes/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "PUT",
      url.toString(),
      JSON.stringify(attributeRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Delete an attribute. Staff only.
   * @summary Delete an attribute
   */
  attributesDestroy(
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/attributes/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "DELETE",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Returns attribute groups for the current organization.
   * @summary List attribute groups
   */
  attributeGroupsList(
    params?: AttributeGroupsListParams,
    requestParameters?: Params,
  ): {
    response: Response;
    data: AttributeGroup[];
  } {
    const url = new URL(
      this.cleanBaseUrl +
        `/attribute-groups/` +
        `?${new URLSearchParams(params).toString()}`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("GET", url.toString(), undefined, {
      ...mergedRequestParameters,
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Create a new attribute group for the current organization. Staff only.
   * @summary Create a new attribute group
   */
  attributeGroupsCreate(
    attributeGroupRequest: AttributeGroupRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: AttributeGroup;
  } {
    const url = new URL(this.cleanBaseUrl + `/attribute-groups/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "POST",
      url.toString(),
      JSON.stringify(attributeGroupRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * Reorder all attribute groups
Request body should contain a list of group IDs in the desired order.
Example: {"group_ids": [5, 1, 3, 2, 4]}
 */
  attributeGroupsReorderCreate(
    attributeGroupRequest: AttributeGroupRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: AttributeGroup;
  } {
    const url = new URL(this.cleanBaseUrl + `/attribute-groups/reorder/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "POST",
      url.toString(),
      JSON.stringify(attributeGroupRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Partially update an existing attribute group. Staff only.
   * @summary Partially update an attribute group
   */
  attributeGroupsPartialUpdate(
    id: number,
    patchedAttributeGroupRequest: PatchedAttributeGroupRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: AttributeGroup;
  } {
    const url = new URL(this.cleanBaseUrl + `/attribute-groups/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "PATCH",
      url.toString(),
      JSON.stringify(patchedAttributeGroupRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Returns details of a specific attribute group.
   * @summary Get a specific attribute group
   */
  attributeGroupsRetrieve(
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: AttributeGroup;
  } {
    const url = new URL(this.cleanBaseUrl + `/attribute-groups/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Update an existing attribute group. Staff only.
   * @summary Update an attribute group
   */
  attributeGroupsUpdate(
    id: number,
    attributeGroupRequest: AttributeGroupRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: AttributeGroup;
  } {
    const url = new URL(this.cleanBaseUrl + `/attribute-groups/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "PUT",
      url.toString(),
      JSON.stringify(attributeGroupRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Delete an attribute group. Staff only.
   * @summary Delete an attribute group
   */
  attributeGroupsDestroy(
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/attribute-groups/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "DELETE",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * Add a single attribute to a group without affecting other attributes.
This is a simpler alternative to the full PATCH operation.
 */
  attributeGroupsAddItemCreate(
    id: number,
    attributeGroupRequest: AttributeGroupRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: AttributeGroup;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/attribute-groups/${id}/add-item/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "POST",
      url.toString(),
      JSON.stringify(attributeGroupRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Delete ONE item from the group, leaving the rest intact and re-ordering.
   */
  attributeGroupsItemsDestroy(
    id: number,
    itemId: string,
    requestParameters?: Params,
  ): {
    response: Response;
    data: void;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/attribute-groups/${id}/items/${itemId}/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "DELETE",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * Reorder items within an attribute group
Request body should contain a list of item IDs in the desired order.
Example: {"item_ids": [5, 1, 3, 2, 4]}
 */
  attributeGroupsReorderItemsCreate(
    id: number,
    attributeGroupRequest: AttributeGroupRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: AttributeGroup;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/attribute-groups/${id}/reorder_items/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "POST",
      url.toString(),
      JSON.stringify(attributeGroupRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Returns a hierarchical tree of categories for the current organization.
   * @summary List all categories
   */
  categoriesList(
    params?: CategoriesListParams,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Category[];
  } {
    const url = new URL(
      this.cleanBaseUrl +
        `/categories/` +
        `?${new URLSearchParams(params).toString()}`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("GET", url.toString(), undefined, {
      ...mergedRequestParameters,
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Create a new category with optional parent.
   * @summary Create a new category
   */
  categoriesCreate(
    categoryRequest: CategoryRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Category;
  } {
    const url = new URL(this.cleanBaseUrl + `/categories/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "POST",
      url.toString(),
      JSON.stringify(categoryRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Move a category to a new parent
   */
  categoriesMoveCreate(
    categoryRequest: CategoryRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Category;
  } {
    const url = new URL(this.cleanBaseUrl + `/categories/move/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "POST",
      url.toString(),
      JSON.stringify(categoryRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Partially update an existing category.
   * @summary Partially update a category
   */
  categoriesPartialUpdate(
    id: number,
    patchedCategoryRequest: PatchedCategoryRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Category;
  } {
    const url = new URL(this.cleanBaseUrl + `/categories/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "PATCH",
      url.toString(),
      JSON.stringify(patchedCategoryRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Returns details of a specific category including its children.
   * @summary Get a specific category
   */
  categoriesRetrieve(
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Category;
  } {
    const url = new URL(this.cleanBaseUrl + `/categories/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Delete a category. This will fail if products are still assigned to it.
   * @summary Delete a category
   */
  categoriesDestroy(
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/categories/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "DELETE",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Return products assigned to this category or any of its subcategories
   */
  categoriesProductsRetrieve(
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Category;
  } {
    const url = new URL(this.cleanBaseUrl + `/categories/${id}/products/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Returns product families for the current organization.
   * @summary List product families
   */
  familiesList(
    params?: FamiliesListParams,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Family[];
  } {
    const url = new URL(
      this.cleanBaseUrl +
        `/families/` +
        `?${new URLSearchParams(params).toString()}`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("GET", url.toString(), undefined, {
      ...mergedRequestParameters,
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Create a new product family for the current organization.
   * @summary Create a new product family
   */
  familiesCreate(
    familyRequest: FamilyRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Family;
  } {
    const url = new URL(this.cleanBaseUrl + `/families/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "POST",
      url.toString(),
      JSON.stringify(familyRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Partially update an existing product family.
   * @summary Partially update a product family
   */
  familiesPartialUpdate(
    id: number,
    patchedFamilyRequest: PatchedFamilyRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Family;
  } {
    const url = new URL(this.cleanBaseUrl + `/families/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "PATCH",
      url.toString(),
      JSON.stringify(patchedFamilyRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Returns details of a specific product family.
   * @summary Get a specific product family
   */
  familiesRetrieve(
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Family;
  } {
    const url = new URL(this.cleanBaseUrl + `/families/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Update an existing product family.
   * @summary Update a product family
   */
  familiesUpdate(
    id: number,
    familyRequest: FamilyRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Family;
  } {
    const url = new URL(this.cleanBaseUrl + `/families/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "PUT",
      url.toString(),
      JSON.stringify(familyRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Delete a product family.
   * @summary Delete a product family
   */
  familiesDestroy(
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/families/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "DELETE",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * API endpoint for managing product families.
   */
  familiesBulkAttributeGroupsCreate(
    id: number,
    familyRequest: FamilyRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Family;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/families/${id}/bulk-attribute-groups/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "POST",
      url.toString(),
      JSON.stringify(familyRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * API endpoint for managing product families.
   */
  familiesAttributeGroupsCreate(
    id: number,
    familyRequest: FamilyRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Family;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/families/${id}/attribute-groups/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "POST",
      url.toString(),
      JSON.stringify(familyRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * API endpoint for managing product families.
   */
  familiesAttributeGroupsRetrieve(
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Family;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/families/${id}/attribute-groups/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * API endpoint for managing product families.
   */
  familiesAttributeGroupsDestroy(
    id: number,
    groupId: string,
    requestParameters?: Params,
  ): {
    response: Response;
    data: void;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/families/${id}/attribute-groups/${groupId}/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "DELETE",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * ViewSet for managing organization locales

Provides CRUD operations for Locale objects associated with the current
user's organization.
 */
  localesList(
    params?: LocalesListParams,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Locale[];
  } {
    const url = new URL(
      this.cleanBaseUrl +
        `/locales/` +
        `?${new URLSearchParams(params).toString()}`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("GET", url.toString(), undefined, {
      ...mergedRequestParameters,
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * ViewSet for managing organization locales

Provides CRUD operations for Locale objects associated with the current
user's organization.
 */
  localesCreate(
    localeRequest: LocaleRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Locale;
  } {
    const url = new URL(this.cleanBaseUrl + `/locales/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "POST",
      url.toString(),
      JSON.stringify(localeRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * ViewSet for managing organization locales

Provides CRUD operations for Locale objects associated with the current
user's organization.
 */
  localesPartialUpdate(
    id: number,
    patchedLocaleRequest: PatchedLocaleRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Locale;
  } {
    const url = new URL(this.cleanBaseUrl + `/locales/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "PATCH",
      url.toString(),
      JSON.stringify(patchedLocaleRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * ViewSet for managing organization locales

Provides CRUD operations for Locale objects associated with the current
user's organization.
 */
  localesRetrieve(
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Locale;
  } {
    const url = new URL(this.cleanBaseUrl + `/locales/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * ViewSet for managing organization locales

Provides CRUD operations for Locale objects associated with the current
user's organization.
 */
  localesUpdate(
    id: number,
    localeRequest: LocaleRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Locale;
  } {
    const url = new URL(this.cleanBaseUrl + `/locales/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "PUT",
      url.toString(),
      JSON.stringify(localeRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * ViewSet for managing organization locales

Provides CRUD operations for Locale objects associated with the current
user's organization.
 */
  localesDestroy(
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/locales/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "DELETE",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * ViewSet for managing organization sales channels

Provides CRUD operations for SalesChannel objects associated with the current
user's organization.
 */
  channelsList(
    params?: ChannelsListParams,
    requestParameters?: Params,
  ): {
    response: Response;
    data: SalesChannel[];
  } {
    const url = new URL(
      this.cleanBaseUrl +
        `/channels/` +
        `?${new URLSearchParams(params).toString()}`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("GET", url.toString(), undefined, {
      ...mergedRequestParameters,
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * ViewSet for managing organization sales channels

Provides CRUD operations for SalesChannel objects associated with the current
user's organization.
 */
  channelsCreate(
    salesChannelRequest: SalesChannelRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: SalesChannel;
  } {
    const url = new URL(this.cleanBaseUrl + `/channels/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "POST",
      url.toString(),
      JSON.stringify(salesChannelRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * ViewSet for managing organization sales channels

Provides CRUD operations for SalesChannel objects associated with the current
user's organization.
 */
  channelsPartialUpdate(
    id: number,
    patchedSalesChannelRequest: PatchedSalesChannelRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: SalesChannel;
  } {
    const url = new URL(this.cleanBaseUrl + `/channels/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "PATCH",
      url.toString(),
      JSON.stringify(patchedSalesChannelRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * ViewSet for managing organization sales channels

Provides CRUD operations for SalesChannel objects associated with the current
user's organization.
 */
  channelsRetrieve(
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: SalesChannel;
  } {
    const url = new URL(this.cleanBaseUrl + `/channels/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * ViewSet for managing organization sales channels

Provides CRUD operations for SalesChannel objects associated with the current
user's organization.
 */
  channelsUpdate(
    id: number,
    salesChannelRequest: SalesChannelRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: SalesChannel;
  } {
    const url = new URL(this.cleanBaseUrl + `/channels/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "PUT",
      url.toString(),
      JSON.stringify(salesChannelRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * ViewSet for managing organization sales channels

Provides CRUD operations for SalesChannel objects associated with the current
user's organization.
 */
  channelsDestroy(
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/channels/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "DELETE",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * Nested under /products/<product_pk>/assets/.
Handles upload, delete, reorder and set-primary.
 */
  productsAssetsList(
    productPk: number,
    params?: ProductsAssetsListParams,
    requestParameters?: Params,
  ): {
    response: Response;
    data: ProductAsset[];
  } {
    const url = new URL(
      this.cleanBaseUrl +
        `/products/${productPk}/assets/` +
        `?${new URLSearchParams(params).toString()}`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("GET", url.toString(), undefined, {
      ...mergedRequestParameters,
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * Nested under /products/<product_pk>/assets/.
Handles upload, delete, reorder and set-primary.
 */
  productsAssetsCreate(
    productPk: number,
    productAssetRequest: ProductAssetRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: ProductAsset;
  } {
    const formData = new FormData();
    formData.append(`file`, productAssetRequest.file);
    if (productAssetRequest.asset_type !== undefined) {
      formData.append(`asset_type`, productAssetRequest.asset_type);
    }
    if (
      productAssetRequest.name !== undefined &&
      productAssetRequest.name !== null
    ) {
      formData.append(`name`, productAssetRequest.name);
    }
    if (productAssetRequest.order !== undefined) {
      formData.append(`order`, productAssetRequest.order.toString());
    }
    if (productAssetRequest.is_primary !== undefined) {
      formData.append(`is_primary`, productAssetRequest.is_primary.toString());
    }
    if (
      productAssetRequest.content_type !== undefined &&
      productAssetRequest.content_type !== null
    ) {
      formData.append(`content_type`, productAssetRequest.content_type);
    }
    if (productAssetRequest.file_size !== undefined) {
      formData.append(`file_size`, productAssetRequest.file_size.toString());
    }
    if (
      productAssetRequest.uploaded_by !== undefined &&
      productAssetRequest.uploaded_by !== null
    ) {
      formData.append(
        `uploaded_by`,
        productAssetRequest.uploaded_by.toString(),
      );
    }
    if (productAssetRequest.tags !== undefined) {
      productAssetRequest.tags.forEach((value) =>
        formData.append(`tags`, value),
      );
    }

    const url = new URL(this.cleanBaseUrl + `/products/${productPk}/assets/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("POST", url.toString(), formData.body(), {
      ...mergedRequestParameters,
      headers: {
        ...mergedRequestParameters?.headers,
        "Content-Type": "multipart/form-data; boundary=" + formData.boundary,
      },
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * Nested under /products/<product_pk>/assets/.
Handles upload, delete, reorder and set-primary.
 */
  productsAssetsBulkDownloadCreate(
    productPk: number,
    productAssetRequest: ProductAssetRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: ProductAsset;
  } {
    const formData = new FormData();
    formData.append(`file`, productAssetRequest.file);
    if (productAssetRequest.asset_type !== undefined) {
      formData.append(`asset_type`, productAssetRequest.asset_type);
    }
    if (
      productAssetRequest.name !== undefined &&
      productAssetRequest.name !== null
    ) {
      formData.append(`name`, productAssetRequest.name);
    }
    if (productAssetRequest.order !== undefined) {
      formData.append(`order`, productAssetRequest.order.toString());
    }
    if (productAssetRequest.is_primary !== undefined) {
      formData.append(`is_primary`, productAssetRequest.is_primary.toString());
    }
    if (
      productAssetRequest.content_type !== undefined &&
      productAssetRequest.content_type !== null
    ) {
      formData.append(`content_type`, productAssetRequest.content_type);
    }
    if (productAssetRequest.file_size !== undefined) {
      formData.append(`file_size`, productAssetRequest.file_size.toString());
    }
    if (
      productAssetRequest.uploaded_by !== undefined &&
      productAssetRequest.uploaded_by !== null
    ) {
      formData.append(
        `uploaded_by`,
        productAssetRequest.uploaded_by.toString(),
      );
    }
    if (productAssetRequest.tags !== undefined) {
      productAssetRequest.tags.forEach((value) =>
        formData.append(`tags`, value),
      );
    }

    const url = new URL(
      this.cleanBaseUrl + `/products/${productPk}/assets/bulk-download/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("POST", url.toString(), formData.body(), {
      ...mergedRequestParameters,
      headers: {
        ...mergedRequestParameters?.headers,
        "Content-Type": "multipart/form-data; boundary=" + formData.boundary,
      },
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * Nested under /products/<product_pk>/assets/.
Handles upload, delete, reorder and set-primary.
 */
  productsAssetsBulkUpdateCreate(
    productPk: number,
    productAssetRequest: ProductAssetRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: ProductAsset;
  } {
    const formData = new FormData();
    formData.append(`file`, productAssetRequest.file);
    if (productAssetRequest.asset_type !== undefined) {
      formData.append(`asset_type`, productAssetRequest.asset_type);
    }
    if (
      productAssetRequest.name !== undefined &&
      productAssetRequest.name !== null
    ) {
      formData.append(`name`, productAssetRequest.name);
    }
    if (productAssetRequest.order !== undefined) {
      formData.append(`order`, productAssetRequest.order.toString());
    }
    if (productAssetRequest.is_primary !== undefined) {
      formData.append(`is_primary`, productAssetRequest.is_primary.toString());
    }
    if (
      productAssetRequest.content_type !== undefined &&
      productAssetRequest.content_type !== null
    ) {
      formData.append(`content_type`, productAssetRequest.content_type);
    }
    if (productAssetRequest.file_size !== undefined) {
      formData.append(`file_size`, productAssetRequest.file_size.toString());
    }
    if (
      productAssetRequest.uploaded_by !== undefined &&
      productAssetRequest.uploaded_by !== null
    ) {
      formData.append(
        `uploaded_by`,
        productAssetRequest.uploaded_by.toString(),
      );
    }
    if (productAssetRequest.tags !== undefined) {
      productAssetRequest.tags.forEach((value) =>
        formData.append(`tags`, value),
      );
    }

    const url = new URL(
      this.cleanBaseUrl + `/products/${productPk}/assets/bulk-update/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("POST", url.toString(), formData.body(), {
      ...mergedRequestParameters,
      headers: {
        ...mergedRequestParameters?.headers,
        "Content-Type": "multipart/form-data; boundary=" + formData.boundary,
      },
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * POST body: [{id: 3, order: 1}, ]
   */
  productsAssetsReorderCreate(
    productPk: number,
    productAssetRequest: ProductAssetRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: ProductAsset;
  } {
    const formData = new FormData();
    formData.append(`file`, productAssetRequest.file);
    if (productAssetRequest.asset_type !== undefined) {
      formData.append(`asset_type`, productAssetRequest.asset_type);
    }
    if (
      productAssetRequest.name !== undefined &&
      productAssetRequest.name !== null
    ) {
      formData.append(`name`, productAssetRequest.name);
    }
    if (productAssetRequest.order !== undefined) {
      formData.append(`order`, productAssetRequest.order.toString());
    }
    if (productAssetRequest.is_primary !== undefined) {
      formData.append(`is_primary`, productAssetRequest.is_primary.toString());
    }
    if (
      productAssetRequest.content_type !== undefined &&
      productAssetRequest.content_type !== null
    ) {
      formData.append(`content_type`, productAssetRequest.content_type);
    }
    if (productAssetRequest.file_size !== undefined) {
      formData.append(`file_size`, productAssetRequest.file_size.toString());
    }
    if (
      productAssetRequest.uploaded_by !== undefined &&
      productAssetRequest.uploaded_by !== null
    ) {
      formData.append(
        `uploaded_by`,
        productAssetRequest.uploaded_by.toString(),
      );
    }
    if (productAssetRequest.tags !== undefined) {
      productAssetRequest.tags.forEach((value) =>
        formData.append(`tags`, value),
      );
    }

    const url = new URL(
      this.cleanBaseUrl + `/products/${productPk}/assets/reorder/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("POST", url.toString(), formData.body(), {
      ...mergedRequestParameters,
      headers: {
        ...mergedRequestParameters?.headers,
        "Content-Type": "multipart/form-data; boundary=" + formData.boundary,
      },
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * Nested under /products/<product_pk>/assets/.
Handles upload, delete, reorder and set-primary.
 */
  productsAssetsPartialUpdate(
    productPk: number,
    id: number,
    patchedProductAssetRequest: PatchedProductAssetRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: ProductAsset;
  } {
    const formData = new FormData();
    if (patchedProductAssetRequest.file !== undefined) {
      formData.append(`file`, patchedProductAssetRequest.file);
    }
    if (patchedProductAssetRequest.asset_type !== undefined) {
      formData.append(`asset_type`, patchedProductAssetRequest.asset_type);
    }
    if (
      patchedProductAssetRequest.name !== undefined &&
      patchedProductAssetRequest.name !== null
    ) {
      formData.append(`name`, patchedProductAssetRequest.name);
    }
    if (patchedProductAssetRequest.order !== undefined) {
      formData.append(`order`, patchedProductAssetRequest.order.toString());
    }
    if (patchedProductAssetRequest.is_primary !== undefined) {
      formData.append(
        `is_primary`,
        patchedProductAssetRequest.is_primary.toString(),
      );
    }
    if (
      patchedProductAssetRequest.content_type !== undefined &&
      patchedProductAssetRequest.content_type !== null
    ) {
      formData.append(`content_type`, patchedProductAssetRequest.content_type);
    }
    if (patchedProductAssetRequest.file_size !== undefined) {
      formData.append(
        `file_size`,
        patchedProductAssetRequest.file_size.toString(),
      );
    }
    if (
      patchedProductAssetRequest.uploaded_by !== undefined &&
      patchedProductAssetRequest.uploaded_by !== null
    ) {
      formData.append(
        `uploaded_by`,
        patchedProductAssetRequest.uploaded_by.toString(),
      );
    }
    if (patchedProductAssetRequest.tags !== undefined) {
      patchedProductAssetRequest.tags.forEach((value) =>
        formData.append(`tags`, value),
      );
    }

    const url = new URL(
      this.cleanBaseUrl + `/products/${productPk}/assets/${id}/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("PATCH", url.toString(), formData.body(), {
      ...mergedRequestParameters,
      headers: {
        ...mergedRequestParameters?.headers,
        "Content-Type": "multipart/form-data; boundary=" + formData.boundary,
      },
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * Nested under /products/<product_pk>/assets/.
Handles upload, delete, reorder and set-primary.
 */
  productsAssetsRetrieve(
    productPk: number,
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: ProductAsset;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/products/${productPk}/assets/${id}/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * Nested under /products/<product_pk>/assets/.
Handles upload, delete, reorder and set-primary.
 */
  productsAssetsUpdate(
    productPk: number,
    id: number,
    productAssetRequest: ProductAssetRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: ProductAsset;
  } {
    const formData = new FormData();
    formData.append(`file`, productAssetRequest.file);
    if (productAssetRequest.asset_type !== undefined) {
      formData.append(`asset_type`, productAssetRequest.asset_type);
    }
    if (
      productAssetRequest.name !== undefined &&
      productAssetRequest.name !== null
    ) {
      formData.append(`name`, productAssetRequest.name);
    }
    if (productAssetRequest.order !== undefined) {
      formData.append(`order`, productAssetRequest.order.toString());
    }
    if (productAssetRequest.is_primary !== undefined) {
      formData.append(`is_primary`, productAssetRequest.is_primary.toString());
    }
    if (
      productAssetRequest.content_type !== undefined &&
      productAssetRequest.content_type !== null
    ) {
      formData.append(`content_type`, productAssetRequest.content_type);
    }
    if (productAssetRequest.file_size !== undefined) {
      formData.append(`file_size`, productAssetRequest.file_size.toString());
    }
    if (
      productAssetRequest.uploaded_by !== undefined &&
      productAssetRequest.uploaded_by !== null
    ) {
      formData.append(
        `uploaded_by`,
        productAssetRequest.uploaded_by.toString(),
      );
    }
    if (productAssetRequest.tags !== undefined) {
      productAssetRequest.tags.forEach((value) =>
        formData.append(`tags`, value),
      );
    }

    const url = new URL(
      this.cleanBaseUrl + `/products/${productPk}/assets/${id}/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("PUT", url.toString(), formData.body(), {
      ...mergedRequestParameters,
      headers: {
        ...mergedRequestParameters?.headers,
        "Content-Type": "multipart/form-data; boundary=" + formData.boundary,
      },
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * Nested under /products/<product_pk>/assets/.
Handles upload, delete, reorder and set-primary.
 */
  productsAssetsDestroy(
    productPk: number,
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: void;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/products/${productPk}/assets/${id}/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "DELETE",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * Nested under /products/<product_pk>/assets/.
Handles upload, delete, reorder and set-primary.
 */
  productsAssetsDownloadRetrieve(
    productPk: number,
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: ProductAsset;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/products/${productPk}/assets/${id}/download/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * Nested under /products/<product_pk>/assets/.
Handles upload, delete, reorder and set-primary.
 */
  productsAssetsDownloadAssetRetrieve(
    productPk: number,
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: ProductAsset;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/products/${productPk}/assets/${id}/download-asset/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * Nested under /products/<product_pk>/assets/.
Handles upload, delete, reorder and set-primary.
 */
  productsAssetsSetPrimaryCreate(
    productPk: number,
    id: number,
    productAssetRequest: ProductAssetRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: ProductAsset;
  } {
    const formData = new FormData();
    formData.append(`file`, productAssetRequest.file);
    if (productAssetRequest.asset_type !== undefined) {
      formData.append(`asset_type`, productAssetRequest.asset_type);
    }
    if (
      productAssetRequest.name !== undefined &&
      productAssetRequest.name !== null
    ) {
      formData.append(`name`, productAssetRequest.name);
    }
    if (productAssetRequest.order !== undefined) {
      formData.append(`order`, productAssetRequest.order.toString());
    }
    if (productAssetRequest.is_primary !== undefined) {
      formData.append(`is_primary`, productAssetRequest.is_primary.toString());
    }
    if (
      productAssetRequest.content_type !== undefined &&
      productAssetRequest.content_type !== null
    ) {
      formData.append(`content_type`, productAssetRequest.content_type);
    }
    if (productAssetRequest.file_size !== undefined) {
      formData.append(`file_size`, productAssetRequest.file_size.toString());
    }
    if (
      productAssetRequest.uploaded_by !== undefined &&
      productAssetRequest.uploaded_by !== null
    ) {
      formData.append(
        `uploaded_by`,
        productAssetRequest.uploaded_by.toString(),
      );
    }
    if (productAssetRequest.tags !== undefined) {
      productAssetRequest.tags.forEach((value) =>
        formData.append(`tags`, value),
      );
    }

    const url = new URL(
      this.cleanBaseUrl + `/products/${productPk}/assets/${id}/set_primary/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("POST", url.toString(), formData.body(), {
      ...mergedRequestParameters,
      headers: {
        ...mergedRequestParameters?.headers,
        "Content-Type": "multipart/form-data; boundary=" + formData.boundary,
      },
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  productsAssetBundlesList(
    productPk: string,
    params?: ProductsAssetBundlesListParams,
    requestParameters?: Params,
  ): {
    response: Response;
    data: AssetBundle[];
  } {
    const url = new URL(
      this.cleanBaseUrl +
        `/products/${productPk}/asset-bundles/` +
        `?${new URLSearchParams(params).toString()}`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("GET", url.toString(), undefined, {
      ...mergedRequestParameters,
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  productsAssetBundlesCreate(
    productPk: string,
    assetBundleRequest: AssetBundleRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: AssetBundle;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/products/${productPk}/asset-bundles/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "POST",
      url.toString(),
      JSON.stringify(assetBundleRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  productsAssetBundlesPartialUpdate(
    productPk: string,
    id: string,
    patchedAssetBundleRequest: PatchedAssetBundleRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: AssetBundle;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/products/${productPk}/asset-bundles/${id}/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "PATCH",
      url.toString(),
      JSON.stringify(patchedAssetBundleRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  productsAssetBundlesRetrieve(
    productPk: string,
    id: string,
    requestParameters?: Params,
  ): {
    response: Response;
    data: AssetBundle;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/products/${productPk}/asset-bundles/${id}/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  productsAssetBundlesUpdate(
    productPk: string,
    id: string,
    assetBundleRequest: AssetBundleRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: AssetBundle;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/products/${productPk}/asset-bundles/${id}/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "PUT",
      url.toString(),
      JSON.stringify(assetBundleRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  productsAssetBundlesDestroy(
    productPk: string,
    id: string,
    requestParameters?: Params,
  ): {
    response: Response;
    data: void;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/products/${productPk}/asset-bundles/${id}/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "DELETE",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  productsAssetBundlesDownloadRetrieve(
    productPk: string,
    id: string,
    requestParameters?: Params,
  ): {
    response: Response;
    data: AssetBundle;
  } {
    const url = new URL(
      this.cleanBaseUrl +
        `/products/${productPk}/asset-bundles/${id}/download/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Returns attribute values for the current organization.
   * @summary List all attribute values
   */
  productsAttributesList(
    productPk: number,
    params?: ProductsAttributesListParams,
    requestParameters?: Params,
  ): {
    response: Response;
    data: AttributeValueDetail[];
  } {
    const url = new URL(
      this.cleanBaseUrl +
        `/products/${productPk}/attributes/` +
        `?${new URLSearchParams(params).toString()}`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("GET", url.toString(), undefined, {
      ...mergedRequestParameters,
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Create a new attribute value for the current organization. Staff only.
   * @summary Create a new attribute value
   */
  productsAttributesCreate(
    productPk: number,
    attributeValueRequest: AttributeValueRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: AttributeValue;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/products/${productPk}/attributes/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "POST",
      url.toString(),
      JSON.stringify(attributeValueRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Create multiple attribute values at once
   */
  productsAttributesBulkCreateCreate(
    productPk: number,
    attributeValueRequest: AttributeValueRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: AttributeValue;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/products/${productPk}/attributes/bulk_create/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "POST",
      url.toString(),
      JSON.stringify(attributeValueRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Partially update an existing attribute value. Staff only.
   * @summary Partially update an attribute value
   */
  productsAttributesPartialUpdate(
    productPk: number,
    id: number,
    patchedAttributeValueRequest: PatchedAttributeValueRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: AttributeValue;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/products/${productPk}/attributes/${id}/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "PATCH",
      url.toString(),
      JSON.stringify(patchedAttributeValueRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Returns details of a specific attribute value.
   * @summary Get a specific attribute value
   */
  productsAttributesRetrieve(
    productPk: number,
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: AttributeValueDetail;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/products/${productPk}/attributes/${id}/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Update an existing attribute value. Staff only.
   * @summary Update an attribute value
   */
  productsAttributesUpdate(
    productPk: number,
    id: number,
    attributeValueRequest: AttributeValueRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: AttributeValue;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/products/${productPk}/attributes/${id}/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "PUT",
      url.toString(),
      JSON.stringify(attributeValueRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Delete an attribute value. Staff only.
   * @summary Delete an attribute value
   */
  productsAttributesDestroy(
    productPk: number,
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: void;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/products/${productPk}/attributes/${id}/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "DELETE",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Returns attribute groups with their values for a specific product.
   * @summary Get attribute groups with values for a product
   */
  productsAttributeGroupsList(
    productPk: string,
    params?: ProductsAttributeGroupsListParams,
    requestParameters?: Params,
  ): {
    response: Response;
    data: AttributeGroup[];
  } {
    const url = new URL(
      this.cleanBaseUrl +
        `/products/${productPk}/attribute-groups/` +
        `?${new URLSearchParams(params).toString()}`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("GET", url.toString(), undefined, {
      ...mergedRequestParameters,
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * API endpoint for retrieving product attribute groups with values.
This is a read-only endpoint that only returns attribute groups
that are inherited from the product's family or modified via overrides.

Products can ONLY have attribute groups through family inheritance and overrides,
not through direct assignment.
 */
  productsAttributeGroupsRetrieve(
    productPk: string,
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: AttributeGroup;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/products/${productPk}/attribute-groups/${id}/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  productsActivitiesList(
    productPk: string,
    params?: ProductsActivitiesListParams,
    requestParameters?: Params,
  ): {
    response: Response;
    data: ProductActivity[];
  } {
    const url = new URL(
      this.cleanBaseUrl +
        `/products/${productPk}/activities/` +
        `?${new URLSearchParams(params).toString()}`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("GET", url.toString(), undefined, {
      ...mergedRequestParameters,
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * API endpoints for managing product family attribute group overrides.

This viewset allows products to override (remove or add) attribute groups
inherited from their family.
 */
  productsFamilyOverridesList(
    productPk: number,
    params?: ProductsFamilyOverridesListParams,
    requestParameters?: Params,
  ): {
    response: Response;
    data: ProductFamilyOverride[];
  } {
    const url = new URL(
      this.cleanBaseUrl +
        `/products/${productPk}/family-overrides/` +
        `?${new URLSearchParams(params).toString()}`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("GET", url.toString(), undefined, {
      ...mergedRequestParameters,
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Handle creation of a single override or bulk override operations
   */
  productsFamilyOverridesCreate(
    productPk: number,
    productFamilyOverrideRequest: ProductFamilyOverrideRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: ProductFamilyOverride;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/products/${productPk}/family-overrides/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "POST",
      url.toString(),
      JSON.stringify(productFamilyOverrideRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * API endpoints for managing product family attribute group overrides.

This viewset allows products to override (remove or add) attribute groups
inherited from their family.
 */
  productsFamilyOverridesDestroy(
    productPk: number,
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: void;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/products/${productPk}/family-overrides/${id}/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "DELETE",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  productsSkuCheckCreate(requestParameters?: Params): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/products/sku-check/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "POST",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Generate a PDF for a product specification
   */
  productsPdfRetrieve(
    productId: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/products/${productId}/pdf/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * Override/remove a specific attribute group for a product.

This endpoint allows hiding or showing a specific attribute group for a product,
regardless of what is required by the product's family.

Request body:
{
    "attribute_group": ID,  # Required: ID of the attribute group to override
    "removed": true/false   # Required: Whether to hide (true) or show (false) the attribute group
}
 */
  productsOverrideGroupCreate(
    productId: number,
    productsOverrideGroupCreateBody: ProductsOverrideGroupCreateBody,
    params: ProductsOverrideGroupCreateParams,
    requestParameters?: Params,
  ): {
    response: Response;
    data: ResponseBody;
  } {
    const url = new URL(
      this.cleanBaseUrl +
        `/products/${productId}/override-group/` +
        `?${new URLSearchParams(params).toString()}`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "POST",
      url.toString(),
      JSON.stringify(productsOverrideGroupCreateBody),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * ViewSet for managing product import tasks.

Supports creating new import tasks, retrieving status, listing all tasks,
canceling tasks, and generating reports of imported data.
 */
  importsList(
    params?: ImportsListParams,
    requestParameters?: Params,
  ): {
    response: Response;
    data: ImportTask[];
  } {
    const url = new URL(
      this.cleanBaseUrl +
        `/imports/` +
        `?${new URLSearchParams(params).toString()}`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("GET", url.toString(), undefined, {
      ...mergedRequestParameters,
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * ViewSet for managing product import tasks.

Supports creating new import tasks, retrieving status, listing all tasks,
canceling tasks, and generating reports of imported data.
 */
  importsCreate(
    importTaskRequest: ImportTaskRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: ImportTask;
  } {
    const formData = new FormData();
    formData.append(`csv_file`, importTaskRequest.csv_file);
    formData.append(`mapping`, JSON.stringify(importTaskRequest.mapping));
    if (importTaskRequest.duplicate_strategy !== undefined) {
      formData.append(
        `duplicate_strategy`,
        importTaskRequest.duplicate_strategy,
      );
    }

    const url = new URL(this.cleanBaseUrl + `/imports/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("POST", url.toString(), formData.body(), {
      ...mergedRequestParameters,
      headers: {
        ...mergedRequestParameters?.headers,
        "Content-Type": "multipart/form-data; boundary=" + formData.boundary,
      },
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * ViewSet for managing product import tasks.

Supports creating new import tasks, retrieving status, listing all tasks,
canceling tasks, and generating reports of imported data.
 */
  importsRetrieve(
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: ImportTask;
  } {
    const url = new URL(this.cleanBaseUrl + `/imports/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * Cancel an in-progress import task.
Only tasks in 'queued' or 'running' state can be canceled.
 */
  importsCancelCreate(
    id: number,
    importTaskRequest: ImportTaskRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: ImportTask;
  } {
    const formData = new FormData();
    formData.append(`csv_file`, importTaskRequest.csv_file);
    formData.append(`mapping`, JSON.stringify(importTaskRequest.mapping));
    if (importTaskRequest.duplicate_strategy !== undefined) {
      formData.append(
        `duplicate_strategy`,
        importTaskRequest.duplicate_strategy,
      );
    }

    const url = new URL(this.cleanBaseUrl + `/imports/${id}/cancel/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("POST", url.toString(), formData.body(), {
      ...mergedRequestParameters,
      headers: {
        ...mergedRequestParameters?.headers,
        "Content-Type": "multipart/form-data; boundary=" + formData.boundary,
      },
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Download the error report for an import task.
   */
  importsGetReportRetrieve(
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: ImportTask;
  } {
    const url = new URL(this.cleanBaseUrl + `/imports/${id}/get_report/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Preview the first 10 rows of the CSV or Excel file.
   */
  importsPreviewRetrieve(
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: ImportTask;
  } {
    const url = new URL(this.cleanBaseUrl + `/imports/${id}/preview/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * ViewSet for importing attribute groups from CSV or Excel files.

This endpoint allows uploading a file containing attribute group definitions
and initiates an async import process.
 */
  attributeGroupsImportList(
    params?: AttributeGroupsImportListParams,
    requestParameters?: Params,
  ): {
    response: Response;
    data: ImportTask[];
  } {
    const url = new URL(
      this.cleanBaseUrl +
        `/attribute-groups-import/` +
        `?${new URLSearchParams(params).toString()}`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("GET", url.toString(), undefined, {
      ...mergedRequestParameters,
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Import attribute groups from a CSV or Excel file
   */
  attributeGroupsImportCreate(
    importTaskRequest: ImportTaskRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: void;
  } {
    const formData = new FormData();
    formData.append(`csv_file`, importTaskRequest.csv_file);
    formData.append(`mapping`, JSON.stringify(importTaskRequest.mapping));
    if (importTaskRequest.duplicate_strategy !== undefined) {
      formData.append(
        `duplicate_strategy`,
        importTaskRequest.duplicate_strategy,
      );
    }

    const url = new URL(this.cleanBaseUrl + `/attribute-groups-import/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("POST", url.toString(), formData.body(), {
      ...mergedRequestParameters,
      headers: {
        ...mergedRequestParameters?.headers,
        "Content-Type": "multipart/form-data; boundary=" + formData.boundary,
      },
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * ViewSet for importing attribute groups from CSV or Excel files.

This endpoint allows uploading a file containing attribute group definitions
and initiates an async import process.
 */
  attributeGroupsImportPartialUpdate(
    id: number,
    patchedImportTaskRequest: PatchedImportTaskRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: ImportTask;
  } {
    const formData = new FormData();
    if (patchedImportTaskRequest.csv_file !== undefined) {
      formData.append(`csv_file`, patchedImportTaskRequest.csv_file);
    }
    if (patchedImportTaskRequest.mapping !== undefined) {
      formData.append(
        `mapping`,
        JSON.stringify(patchedImportTaskRequest.mapping),
      );
    }
    if (patchedImportTaskRequest.duplicate_strategy !== undefined) {
      formData.append(
        `duplicate_strategy`,
        patchedImportTaskRequest.duplicate_strategy,
      );
    }

    const url = new URL(this.cleanBaseUrl + `/attribute-groups-import/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("PATCH", url.toString(), formData.body(), {
      ...mergedRequestParameters,
      headers: {
        ...mergedRequestParameters?.headers,
        "Content-Type": "multipart/form-data; boundary=" + formData.boundary,
      },
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * ViewSet for importing attribute groups from CSV or Excel files.

This endpoint allows uploading a file containing attribute group definitions
and initiates an async import process.
 */
  attributeGroupsImportRetrieve(
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: ImportTask;
  } {
    const url = new URL(this.cleanBaseUrl + `/attribute-groups-import/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * ViewSet for importing attribute groups from CSV or Excel files.

This endpoint allows uploading a file containing attribute group definitions
and initiates an async import process.
 */
  attributeGroupsImportUpdate(
    id: number,
    importTaskRequest: ImportTaskRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: ImportTask;
  } {
    const formData = new FormData();
    formData.append(`csv_file`, importTaskRequest.csv_file);
    formData.append(`mapping`, JSON.stringify(importTaskRequest.mapping));
    if (importTaskRequest.duplicate_strategy !== undefined) {
      formData.append(
        `duplicate_strategy`,
        importTaskRequest.duplicate_strategy,
      );
    }

    const url = new URL(this.cleanBaseUrl + `/attribute-groups-import/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("PUT", url.toString(), formData.body(), {
      ...mergedRequestParameters,
      headers: {
        ...mergedRequestParameters?.headers,
        "Content-Type": "multipart/form-data; boundary=" + formData.boundary,
      },
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * ViewSet for importing attribute groups from CSV or Excel files.

This endpoint allows uploading a file containing attribute group definitions
and initiates an async import process.
 */
  attributeGroupsImportDestroy(
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/attribute-groups-import/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "DELETE",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * ViewSet for importing attributes from CSV or Excel files.

This endpoint allows uploading a file containing attribute definitions
and initiates an async import process.
 */
  attributesImportList(
    params?: AttributesImportListParams,
    requestParameters?: Params,
  ): {
    response: Response;
    data: ImportTask[];
  } {
    const url = new URL(
      this.cleanBaseUrl +
        `/attributes-import/` +
        `?${new URLSearchParams(params).toString()}`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("GET", url.toString(), undefined, {
      ...mergedRequestParameters,
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Import attributes from a CSV or Excel file
   */
  attributesImportCreate(
    importTaskRequest: ImportTaskRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: void;
  } {
    const formData = new FormData();
    formData.append(`csv_file`, importTaskRequest.csv_file);
    formData.append(`mapping`, JSON.stringify(importTaskRequest.mapping));
    if (importTaskRequest.duplicate_strategy !== undefined) {
      formData.append(
        `duplicate_strategy`,
        importTaskRequest.duplicate_strategy,
      );
    }

    const url = new URL(this.cleanBaseUrl + `/attributes-import/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("POST", url.toString(), formData.body(), {
      ...mergedRequestParameters,
      headers: {
        ...mergedRequestParameters?.headers,
        "Content-Type": "multipart/form-data; boundary=" + formData.boundary,
      },
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * ViewSet for importing attributes from CSV or Excel files.

This endpoint allows uploading a file containing attribute definitions
and initiates an async import process.
 */
  attributesImportPartialUpdate(
    id: number,
    patchedImportTaskRequest: PatchedImportTaskRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: ImportTask;
  } {
    const formData = new FormData();
    if (patchedImportTaskRequest.csv_file !== undefined) {
      formData.append(`csv_file`, patchedImportTaskRequest.csv_file);
    }
    if (patchedImportTaskRequest.mapping !== undefined) {
      formData.append(
        `mapping`,
        JSON.stringify(patchedImportTaskRequest.mapping),
      );
    }
    if (patchedImportTaskRequest.duplicate_strategy !== undefined) {
      formData.append(
        `duplicate_strategy`,
        patchedImportTaskRequest.duplicate_strategy,
      );
    }

    const url = new URL(this.cleanBaseUrl + `/attributes-import/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("PATCH", url.toString(), formData.body(), {
      ...mergedRequestParameters,
      headers: {
        ...mergedRequestParameters?.headers,
        "Content-Type": "multipart/form-data; boundary=" + formData.boundary,
      },
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * ViewSet for importing attributes from CSV or Excel files.

This endpoint allows uploading a file containing attribute definitions
and initiates an async import process.
 */
  attributesImportRetrieve(
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: ImportTask;
  } {
    const url = new URL(this.cleanBaseUrl + `/attributes-import/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * ViewSet for importing attributes from CSV or Excel files.

This endpoint allows uploading a file containing attribute definitions
and initiates an async import process.
 */
  attributesImportUpdate(
    id: number,
    importTaskRequest: ImportTaskRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: ImportTask;
  } {
    const formData = new FormData();
    formData.append(`csv_file`, importTaskRequest.csv_file);
    formData.append(`mapping`, JSON.stringify(importTaskRequest.mapping));
    if (importTaskRequest.duplicate_strategy !== undefined) {
      formData.append(
        `duplicate_strategy`,
        importTaskRequest.duplicate_strategy,
      );
    }

    const url = new URL(this.cleanBaseUrl + `/attributes-import/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("PUT", url.toString(), formData.body(), {
      ...mergedRequestParameters,
      headers: {
        ...mergedRequestParameters?.headers,
        "Content-Type": "multipart/form-data; boundary=" + formData.boundary,
      },
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * ViewSet for importing attributes from CSV or Excel files.

This endpoint allows uploading a file containing attribute definitions
and initiates an async import process.
 */
  attributesImportDestroy(
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/attributes-import/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "DELETE",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * ViewSet for importing product families from CSV or Excel files.

This endpoint allows uploading a file containing family definitions
and initiates an async import process.
 */
  familiesImportList(
    params?: FamiliesImportListParams,
    requestParameters?: Params,
  ): {
    response: Response;
    data: ImportTask[];
  } {
    const url = new URL(
      this.cleanBaseUrl +
        `/families-import/` +
        `?${new URLSearchParams(params).toString()}`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("GET", url.toString(), undefined, {
      ...mergedRequestParameters,
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Import product families from a CSV or Excel file
   */
  familiesImportCreate(
    importTaskRequest: ImportTaskRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: void;
  } {
    const formData = new FormData();
    formData.append(`csv_file`, importTaskRequest.csv_file);
    formData.append(`mapping`, JSON.stringify(importTaskRequest.mapping));
    if (importTaskRequest.duplicate_strategy !== undefined) {
      formData.append(
        `duplicate_strategy`,
        importTaskRequest.duplicate_strategy,
      );
    }

    const url = new URL(this.cleanBaseUrl + `/families-import/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("POST", url.toString(), formData.body(), {
      ...mergedRequestParameters,
      headers: {
        ...mergedRequestParameters?.headers,
        "Content-Type": "multipart/form-data; boundary=" + formData.boundary,
      },
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * ViewSet for importing product families from CSV or Excel files.

This endpoint allows uploading a file containing family definitions
and initiates an async import process.
 */
  familiesImportPartialUpdate(
    id: number,
    patchedImportTaskRequest: PatchedImportTaskRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: ImportTask;
  } {
    const formData = new FormData();
    if (patchedImportTaskRequest.csv_file !== undefined) {
      formData.append(`csv_file`, patchedImportTaskRequest.csv_file);
    }
    if (patchedImportTaskRequest.mapping !== undefined) {
      formData.append(
        `mapping`,
        JSON.stringify(patchedImportTaskRequest.mapping),
      );
    }
    if (patchedImportTaskRequest.duplicate_strategy !== undefined) {
      formData.append(
        `duplicate_strategy`,
        patchedImportTaskRequest.duplicate_strategy,
      );
    }

    const url = new URL(this.cleanBaseUrl + `/families-import/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("PATCH", url.toString(), formData.body(), {
      ...mergedRequestParameters,
      headers: {
        ...mergedRequestParameters?.headers,
        "Content-Type": "multipart/form-data; boundary=" + formData.boundary,
      },
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * ViewSet for importing product families from CSV or Excel files.

This endpoint allows uploading a file containing family definitions
and initiates an async import process.
 */
  familiesImportRetrieve(
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: ImportTask;
  } {
    const url = new URL(this.cleanBaseUrl + `/families-import/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * ViewSet for importing product families from CSV or Excel files.

This endpoint allows uploading a file containing family definitions
and initiates an async import process.
 */
  familiesImportUpdate(
    id: number,
    importTaskRequest: ImportTaskRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: ImportTask;
  } {
    const formData = new FormData();
    formData.append(`csv_file`, importTaskRequest.csv_file);
    formData.append(`mapping`, JSON.stringify(importTaskRequest.mapping));
    if (importTaskRequest.duplicate_strategy !== undefined) {
      formData.append(
        `duplicate_strategy`,
        importTaskRequest.duplicate_strategy,
      );
    }

    const url = new URL(this.cleanBaseUrl + `/families-import/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("PUT", url.toString(), formData.body(), {
      ...mergedRequestParameters,
      headers: {
        ...mergedRequestParameters?.headers,
        "Content-Type": "multipart/form-data; boundary=" + formData.boundary,
      },
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * ViewSet for importing product families from CSV or Excel files.

This endpoint allows uploading a file containing family definitions
and initiates an async import process.
 */
  familiesImportDestroy(
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/families-import/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "DELETE",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Get the canonical schema of importable fields
   */
  fieldSchemaRetrieve(
    params?: FieldSchemaRetrieveParams,
    requestParameters?: Params,
  ): {
    response: Response;
    data: FieldSchemaRetrieve200;
  } {
    const url = new URL(
      this.cleanBaseUrl +
        `/field-schema/` +
        `?${new URLSearchParams(params).toString()}`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("GET", url.toString(), undefined, {
      ...mergedRequestParameters,
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Get the schema for attribute group import fields
   */
  attributeGroupsSchemaRetrieve(requestParameters?: Params): {
    response: Response;
    data: AttributeGroupsSchemaRetrieve200;
  } {
    const url = new URL(this.cleanBaseUrl + `/attribute-groups-schema/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Get the schema for attribute import fields
   */
  attributesSchemaRetrieve(requestParameters?: Params): {
    response: Response;
    data: AttributesSchemaRetrieve200;
  } {
    const url = new URL(this.cleanBaseUrl + `/attributes-schema/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Get the schema for family import fields
   */
  familiesSchemaRetrieve(requestParameters?: Params): {
    response: Response;
    data: FamiliesSchemaRetrieve200;
  } {
    const url = new URL(this.cleanBaseUrl + `/families-schema/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Public list of available report themes.
   */
  reportsThemesList(
    params?: ReportsThemesListParams,
    requestParameters?: Params,
  ): {
    response: Response;
    data: ReportTheme[];
  } {
    const url = new URL(
      this.cleanBaseUrl +
        `/reports/themes/` +
        `?${new URLSearchParams(params).toString()}`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("GET", url.toString(), undefined, {
      ...mergedRequestParameters,
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Public list of available report themes.
   */
  reportsThemesRetrieve(
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: ReportTheme;
  } {
    const url = new URL(this.cleanBaseUrl + `/reports/themes/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Returns available product categories for filtering
   */
  analyticsCategoriesRetrieve(requestParameters?: Params): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/analytics/categories/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Returns change history/audit trail data
   */
  analyticsChangeHistoryRetrieve(requestParameters?: Params): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/analytics/change-history/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Returns available channels for filtering
   */
  analyticsChannelsRetrieve(requestParameters?: Params): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/analytics/channels/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Returns data about product data completeness across attributes and categories
   */
  analyticsCompletenessRetrieve(requestParameters?: Params): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/analytics/completeness/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Returns data about enrichment velocity (edits per day)
   */
  analyticsEnrichmentVelocityRetrieve(requestParameters?: Params): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/analytics/enrichment-velocity/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Returns available locales for filtering
   */
  analyticsLocalesRetrieve(requestParameters?: Params): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/analytics/locales/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Returns data about localization quality by locale
   */
  analyticsLocalizationQualityRetrieve(requestParameters?: Params): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/analytics/localization-quality/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Returns data about product readiness for different channels
   */
  analyticsReadinessRetrieve(requestParameters?: Params): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/analytics/readiness/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Direct function-based view for exporting completeness report
   */
  completenessExportRetrieve(requestParameters?: Params): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/completeness-export/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Direct function-based view for exporting readiness report
   */
  readinessExportRetrieve(requestParameters?: Params): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/readiness-export/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Direct function-based view for exporting enrichment velocity report
   */
  enrichmentVelocityExportRetrieve(requestParameters?: Params): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/enrichment-velocity-export/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Direct function-based view for exporting localization quality report
   */
  localizationQualityExportRetrieve(requestParameters?: Params): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/localization-quality-export/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Direct function-based view for exporting change history report
   */
  changeHistoryExportRetrieve(requestParameters?: Params): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/change-history-export/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * API endpoint for localization quality analytics.

GET: Retrieve analytics on attribute translation quality by locale.
 */
  localizationQualityRetrieve(requestParameters?: Params): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/localization-quality/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  orgsRolesList(
    orgId: number,
    params?: OrgsRolesListParams,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Role[];
  } {
    const url = new URL(
      this.cleanBaseUrl +
        `/orgs/${orgId}/roles/` +
        `?${new URLSearchParams(params).toString()}`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("GET", url.toString(), undefined, {
      ...mergedRequestParameters,
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  orgsRolesCreate(
    orgId: number,
    roleRequest: RoleRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Role;
  } {
    const url = new URL(this.cleanBaseUrl + `/orgs/${orgId}/roles/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "POST",
      url.toString(),
      JSON.stringify(roleRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  orgsRolesPartialUpdate(
    orgId: number,
    id: number,
    patchedRoleRequest: PatchedRoleRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Role;
  } {
    const url = new URL(this.cleanBaseUrl + `/orgs/${orgId}/roles/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "PATCH",
      url.toString(),
      JSON.stringify(patchedRoleRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  orgsRolesRetrieve(
    orgId: number,
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Role;
  } {
    const url = new URL(this.cleanBaseUrl + `/orgs/${orgId}/roles/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  orgsRolesUpdate(
    orgId: number,
    id: number,
    roleRequest: RoleRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Role;
  } {
    const url = new URL(this.cleanBaseUrl + `/orgs/${orgId}/roles/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "PUT",
      url.toString(),
      JSON.stringify(roleRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  orgsRolesDestroy(
    orgId: number,
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/orgs/${orgId}/roles/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "DELETE",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  orgsMembershipsList(
    orgId: number,
    params?: OrgsMembershipsListParams,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Membership[];
  } {
    const url = new URL(
      this.cleanBaseUrl +
        `/orgs/${orgId}/memberships/` +
        `?${new URLSearchParams(params).toString()}`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("GET", url.toString(), undefined, {
      ...mergedRequestParameters,
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * Invite a user to the organization. If user doesn't exist, creates the account.

Expected payload:
{
    "email": "user@example.com",
    "role_id": 1
}
 */
  orgsMembershipsCreate(
    orgId: number,
    membershipRequest: MembershipRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Membership;
  } {
    const url = new URL(this.cleanBaseUrl + `/orgs/${orgId}/memberships/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "POST",
      url.toString(),
      JSON.stringify(membershipRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  orgsMembershipsInvitesRetrieve(
    orgId: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Membership;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/orgs/${orgId}/memberships/invites/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Update a membership (e.g., change role) and log the change
   */
  orgsMembershipsPartialUpdate(
    orgId: number,
    id: number,
    patchedMembershipRequest: PatchedMembershipRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Membership;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/orgs/${orgId}/memberships/${id}/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "PATCH",
      url.toString(),
      JSON.stringify(patchedMembershipRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  orgsMembershipsRetrieve(
    orgId: number,
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Membership;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/orgs/${orgId}/memberships/${id}/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  orgsMembershipsUpdate(
    orgId: number,
    id: number,
    membershipRequest: MembershipRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Membership;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/orgs/${orgId}/memberships/${id}/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "PUT",
      url.toString(),
      JSON.stringify(membershipRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Remove a membership and log the action
   */
  orgsMembershipsDestroy(
    orgId: number,
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: void;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/orgs/${orgId}/memberships/${id}/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "DELETE",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * Accept an invitation to join an organization.

Expected payload:
{
    "name": "Full Name",
    "password": "securepassword",
    "password_confirm": "securepassword",
    "invitation_token": "token"
}
 */
  orgsMembershipsAcceptCreate(
    orgId: number,
    id: number,
    membershipRequest: MembershipRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Membership;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/orgs/${orgId}/memberships/${id}/accept/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "POST",
      url.toString(),
      JSON.stringify(membershipRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * Check if an invitation is valid without requiring authentication.
Used when a user follows an invitation link to verify the email and determine next steps.
 */
  orgsMembershipsCheckInvitationRetrieve(
    orgId: number,
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Membership;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/orgs/${orgId}/memberships/${id}/check_invitation/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  orgsMembershipsResendInviteCreate(
    orgId: number,
    id: number,
    membershipRequest: MembershipRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Membership;
  } {
    const url = new URL(
      this.cleanBaseUrl + `/orgs/${orgId}/memberships/${id}/resend_invite/`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "POST",
      url.toString(),
      JSON.stringify(membershipRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  orgsAuditList(
    orgId: number,
    params?: OrgsAuditListParams,
    requestParameters?: Params,
  ): {
    response: Response;
    data: AuditLog[];
  } {
    const url = new URL(
      this.cleanBaseUrl +
        `/orgs/${orgId}/audit/` +
        `?${new URLSearchParams(params).toString()}`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("GET", url.toString(), undefined, {
      ...mergedRequestParameters,
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  orgsAuditRetrieve(
    orgId: number,
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: AuditLog;
  } {
    const url = new URL(this.cleanBaseUrl + `/orgs/${orgId}/audit/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
 * Check if an invitation is valid without requiring authentication.
Used when a user follows an invitation link to verify the email and determine next steps.
 */
  orgsMembershipsCheckRetrieve(
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Membership;
  } {
    const url = new URL(this.cleanBaseUrl + `/orgs/memberships/${id}/check/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * API endpoint for Currency CRUD operations.
   */
  currenciesList(
    params?: CurrenciesListParams,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Currency[];
  } {
    const url = new URL(
      this.cleanBaseUrl +
        `/currencies/` +
        `?${new URLSearchParams(params).toString()}`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("GET", url.toString(), undefined, {
      ...mergedRequestParameters,
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * API endpoint for Currency CRUD operations.
   */
  currenciesCreate(
    currencyRequest: CurrencyRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Currency;
  } {
    const url = new URL(this.cleanBaseUrl + `/currencies/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "POST",
      url.toString(),
      JSON.stringify(currencyRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * API endpoint for Currency CRUD operations.
   */
  currenciesPartialUpdate(
    isoCode: string,
    patchedCurrencyRequest: PatchedCurrencyRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Currency;
  } {
    const url = new URL(this.cleanBaseUrl + `/currencies/${isoCode}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "PATCH",
      url.toString(),
      JSON.stringify(patchedCurrencyRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * API endpoint for Currency CRUD operations.
   */
  currenciesRetrieve(
    isoCode: string,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Currency;
  } {
    const url = new URL(this.cleanBaseUrl + `/currencies/${isoCode}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * API endpoint for Currency CRUD operations.
   */
  currenciesUpdate(
    isoCode: string,
    currencyRequest: CurrencyRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: Currency;
  } {
    const url = new URL(this.cleanBaseUrl + `/currencies/${isoCode}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "PUT",
      url.toString(),
      JSON.stringify(currencyRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * API endpoint for Currency CRUD operations.
   */
  currenciesDestroy(
    isoCode: string,
    requestParameters?: Params,
  ): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/currencies/${isoCode}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "DELETE",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * API endpoint for PriceType CRUD operations.
   */
  priceTypesList(
    params?: PriceTypesListParams,
    requestParameters?: Params,
  ): {
    response: Response;
    data: PriceType[];
  } {
    const url = new URL(
      this.cleanBaseUrl +
        `/price-types/` +
        `?${new URLSearchParams(params).toString()}`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("GET", url.toString(), undefined, {
      ...mergedRequestParameters,
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * API endpoint for PriceType CRUD operations.
   */
  priceTypesCreate(
    priceTypeRequest: PriceTypeRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: PriceType;
  } {
    const url = new URL(this.cleanBaseUrl + `/price-types/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "POST",
      url.toString(),
      JSON.stringify(priceTypeRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * API endpoint for PriceType CRUD operations.
   */
  priceTypesPartialUpdate(
    id: number,
    patchedPriceTypeRequest: PatchedPriceTypeRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: PriceType;
  } {
    const url = new URL(this.cleanBaseUrl + `/price-types/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "PATCH",
      url.toString(),
      JSON.stringify(patchedPriceTypeRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * API endpoint for PriceType CRUD operations.
   */
  priceTypesRetrieve(
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: PriceType;
  } {
    const url = new URL(this.cleanBaseUrl + `/price-types/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * API endpoint for PriceType CRUD operations.
   */
  priceTypesUpdate(
    id: number,
    priceTypeRequest: PriceTypeRequest,
    requestParameters?: Params,
  ): {
    response: Response;
    data: PriceType;
  } {
    const url = new URL(this.cleanBaseUrl + `/price-types/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "PUT",
      url.toString(),
      JSON.stringify(priceTypeRequest),
      {
        ...mergedRequestParameters,
        headers: {
          ...mergedRequestParameters?.headers,
          "Content-Type": "application/json",
        },
      },
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * API endpoint for PriceType CRUD operations.
   */
  priceTypesDestroy(
    id: number,
    requestParameters?: Params,
  ): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/price-types/${id}/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "DELETE",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * API View for user registration
   */
  registerCreate(requestParameters?: Params): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/register/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "POST",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * API View for user login
   */
  loginCreate(requestParameters?: Params): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/login/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "POST",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * API View for user logout - blacklists the refresh token
   */
  logoutCreate(requestParameters?: Params): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/logout/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "POST",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * API View for setting password for existing users (typically from invitation)
   */
  setPasswordCreate(requestParameters?: Params): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/set-password/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "POST",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * API View to check if a user exists and needs to set a password
   */
  checkUserCreate(requestParameters?: Params): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/check-user/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "POST",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * API View to retrieve authenticated user information
   */
  userRetrieve(requestParameters?: Params): {
    response: Response;
    data: User;
  } {
    const url = new URL(this.cleanBaseUrl + `/user/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * API View to list all users (admin only)
   */
  usersList(
    params?: UsersListParams,
    requestParameters?: Params,
  ): {
    response: Response;
    data: User[];
  } {
    const url = new URL(
      this.cleanBaseUrl +
        `/users/` +
        `?${new URLSearchParams(params).toString()}`,
    );
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request("GET", url.toString(), undefined, {
      ...mergedRequestParameters,
    });
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  usersMeRetrieve(requestParameters?: Params): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/users/me/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  testDbRetrieve(requestParameters?: Params): {
    response: Response;
    data: void;
  } {
    const url = new URL(this.cleanBaseUrl + `/test-db/`);
    const mergedRequestParameters = this._mergeRequestParameters(
      requestParameters || {},
      this.commonRequestParameters,
    );
    const response = http.request(
      "GET",
      url.toString(),
      undefined,
      mergedRequestParameters,
    );
    let data;

    try {
      data = response.json();
    } catch {
      data = response.body;
    }
    return {
      response,
      data,
    };
  }

  /**
   * Merges the provided request parameters with default parameters for the client.
   *
   * @param {Params} requestParameters - The parameters provided specifically for the request
   * @param {Params} commonRequestParameters - Common parameters for all requests
   * @returns {Params} - The merged parameters
   */
  private _mergeRequestParameters(
    requestParameters?: Params,
    commonRequestParameters?: Params,
  ): Params {
    return {
      ...commonRequestParameters, // Default to common parameters
      ...requestParameters, // Override with request-specific parameters
      headers: {
        ...(commonRequestParameters?.headers || {}), // Ensure headers are defined
        ...(requestParameters?.headers || {}),
      },
      cookies: {
        ...(commonRequestParameters?.cookies || {}), // Ensure cookies are defined
        ...(requestParameters?.cookies || {}),
      },
      tags: {
        ...(commonRequestParameters?.tags || {}), // Ensure tags are defined
        ...(requestParameters?.tags || {}),
      },
    };
  }
}
